(function () {
  typeof Math.sgn === 'undefined' && (Math.sgn = function (a) { return a == 0 ? 0 : a > 0 ? 1 : -1; }); var a = {
      subtract(a, b) { return { x: a.x - b.x, y: a.y - b.y }; }, dotProduct(a, b) { return a.x * b.x + a.y * b.y; }, square(a) { return Math.sqrt(a.x * a.x + a.y * a.y); }, scale(a, b) { return { x: a.x * b, y: a.y * b }; }
    },
    b = 64,
    c = Math.pow(2, -b - 1),
    d = function (b, c) { for (var d = [], e = f(b, c), h = c.length - 1, i = 2 * h - 1, j = g(e, i, d, 0), k = a.subtract(b, c[0]), m = a.square(k), n = 0, o = 0; j > o; o++) { k = a.subtract(b, l(c, h, d[o], null, null)); var p = a.square(k); m > p && (m = p, n = d[o]); } return k = a.subtract(b, c[h]), p = a.square(k), m > p && (m = p, n = 1), { location: n, distance: m }; },
    e = function (a, b) { const c = d(a, b); return { point: l(b, b.length - 1, c.location, null, null), location: c.location }; },
    f = function (b, c) {
      for (var d = c.length - 1, e = 2 * d - 1, f = [], g = [], h = [], i = [], k = [[1, 0.6, 0.3, 0.1], [0.4, 0.6, 0.6, 0.4], [0.1, 0.3, 0.6, 1]], l = 0; d >= l; l++)f[l] = a.subtract(c[l], b); for (var l = 0; d - 1 >= l; l++)g[l] = a.subtract(c[l + 1], c[l]), g[l] = a.scale(g[l], 3); for (let m = 0; d - 1 >= m; m++) for (let n = 0; d >= n; n++)h[m] || (h[m] = []), h[m][n] = a.dotProduct(g[m], f[n]); for (l = 0; e >= l; l++)i[l] || (i[l] = []), i[l].y = 0, i[l].x = parseFloat(l) / e; for (let o = d, p = d - 1, q = 0; o + p >= q; q++) {
        let r = Math.max(0, q - p),
          s = Math.min(q, o); for (l = r; s >= l; l++)j = q - l, i[l + j].y += h[j][l] * k[j][l];
      } return i;
    },
    g = function (a, c, d, e) {
      let f,
        j,
        m = [],
        n = [],
        o = [],
        p = []; switch (h(a, c)) { case 0: return 0; case 1: if (e >= b) return d[0] = (a[0].x + a[c].x) / 2, 1; if (i(a, c)) return d[0] = k(a, c), 1; }l(a, c, 0.5, m, n), f = g(m, c, o, e + 1), j = g(n, c, p, e + 1); for (var q = 0; f > q; q++)d[q] = o[q]; for (var q = 0; j > q; q++)d[q + f] = p[q]; return f + j;
    },
    h = function (a, b) {
      let c,
        d,
        e = 0; c = d = Math.sgn(a[0].y); for (let f = 1; b >= f; f++)c = Math.sgn(a[f].y), c != d && e++, d = c; return e;
    },
    i = function (a, b) {
      let d,
        e,
        f,
        g,
        h,
        i,
        j,
        k,
        l,
        m,
        n,
        o,
        p,
        q,
        r,
        s; i = a[0].y - a[b].y, j = a[b].x - a[0].x, k = a[0].x * a[b].y - a[b].x * a[0].y; for (var t = max_distance_below = 0, u = 1; b > u; u++) { const v = i * a[u].x + j * a[u].y + k; v > t ? t = v : max_distance_below > v && (max_distance_below = v); } return n = 0, o = 1, p = 0, q = i, r = j, s = k - t, l = n * r - q * o, m = 1 / l, e = (o * s - r * p) * m, q = i, r = j, s = k - max_distance_below, l = n * r - q * o, m = 1 / l, f = (o * s - r * p) * m, g = Math.min(e, f), h = Math.max(e, f), d = h - g, c > d ? 1 : 0;
    },
    k = function (a, b) {
      let c = 1,
        d = 0,
        e = a[b].x - a[0].x,
        f = a[b].y - a[0].y,
        g = a[0].x - 0,
        h = a[0].y - 0,
        i = e * d - f * c,
        j = 1 / i,
        k = (e * h - f * g) * j; return 0 + c * k;
    },
    l = function (a, b, c, d, e) { for (var f = [[]], g = 0; b >= g; g++)f[0][g] = a[g]; for (let h = 1; b >= h; h++) for (var g = 0; b - h >= g; g++)f[h] || (f[h] = []), f[h][g] || (f[h][g] = {}), f[h][g].x = (1 - c) * f[h - 1][g].x + c * f[h - 1][g + 1].x, f[h][g].y = (1 - c) * f[h - 1][g].y + c * f[h - 1][g + 1].y; if (d != null) for (g = 0; b >= g; g++)d[g] = f[g][0]; if (e != null) for (g = 0; b >= g; g++)e[g] = f[b - g][g]; return f[b][0]; },
    m = {},
    n = function (a) {
      let b = m[a]; if (!b) {
        b = []; let c = function () { return function (b) { return Math.pow(b, a); }; },
          d = function () { return function (b) { return Math.pow(1 - b, a); }; },
          e = function (a) { return function () { return a; }; },
          f = function () { return function (a) { return a; }; },
          g = function () { return function (a) { return 1 - a; }; },
          h = function (a) { return function (b) { for (var c = 1, d = 0; d < a.length; d++)c *= a[d](b); return c; }; }; b.push(new c()); for (let i = 1; a > i; i++) { for (var j = [new e(a)], k = 0; a - i > k; k++)j.push(new f()); for (var k = 0; i > k; k++)j.push(new g()); b.push(new h(j)); }b.push(new d()), m[a] = b;
      } return b;
    },
    o = function (a, b) { for (var c = n(a.length - 1), d = 0, e = 0, f = 0; f < a.length; f++)d += a[f].x * c[f](b), e += a[f].y * c[f](b); return { x: d, y: e }; },
    p = function (a, b) { return Math.sqrt(Math.pow(a.x - b.x, 2) + Math.pow(a.y - b.y, 2)); },
    q = function (a) { return a[0].x == a[1].x && a[0].y == a[1].y; },
    r = function (a, b, c) { if (q(a)) return { point: a[0], location: b }; for (var d = o(a, b), e = 0, f = b, g = c > 0 ? 1 : -1, h = null; e < Math.abs(c);)f += 0.005 * g, h = o(a, f), e += p(h, d), d = h; return { point: h, location: f }; },
    s = function (a) { if (q(a)) return 0; for (var b = o(a, 0), c = 0, d = 0, e = 1, f = null; d < 1;)d += 0.005 * e, f = o(a, d), c += p(f, b), b = f; return c; },
    t = function (a, b, c) { return r(a, b, c).point; },
    u = function (a, b, c) { return r(a, b, c).location; },
    v = function (a, b) {
      let c = o(a, b),
        d = o(a.slice(0, a.length - 1), b),
        e = d.y - c.y,
        f = d.x - c.x; return e == 0 ? 1 / 0 : Math.atan(e / f);
    },
    w = function (a, b, c) { const d = r(a, b, c); return d.location > 1 && (d.location = 1), d.location < 0 && (d.location = 0), v(a, d.location); },
    x = function (a, b, c, d) {
      d = d == null ? 0 : d; let e = r(a, b, d),
        f = v(a, e.location),
        g = Math.atan(-1 / f),
        h = c / 2 * Math.sin(g),
        i = c / 2 * Math.cos(g); return [{ x: e.point.x + i, y: e.point.y + h }, { x: e.point.x - i, y: e.point.y - h }];
    },
    y = this.jsBezier = {
      distanceFromCurve: d, gradientAtPoint: v, gradientAtPointAlongCurveFrom: w, nearestPointOnCurve: e, pointOnCurve: o, pointAlongCurveFrom: t, perpendicularToCurveAt: x, locationAlongCurveFrom: u, getLength: s, version: '0.9.0'
    }; typeof exports !== 'undefined' && (exports.jsBezier = y);
}).call(typeof window !== 'undefined' ? window : this), function () {
  let a = this,
    b = a.Biltong = { version: '0.4.0' }; typeof exports !== 'undefined' && (exports.Biltong = b); let c = function (a) { return Object.prototype.toString.call(a) === '[object Array]'; },
    d = function (a, b, d) { return a = c(a) ? a : [a.x, a.y], b = c(b) ? b : [b.x, b.y], d(a, b); },
    e = b.gradient = function (a, b) { return d(a, b, (a, b) => (b[0] == a[0] ? b[1] > a[1] ? 1 / 0 : -1 / 0 : b[1] == a[1] ? b[0] > a[0] ? 0 : -0 : (b[1] - a[1]) / (b[0] - a[0]))); },
    f = (b.normal = function (a, b) { return -1 / e(a, b); }, b.lineLength = function (a, b) { return d(a, b, (a, b) => Math.sqrt(Math.pow(b[1] - a[1], 2) + Math.pow(b[0] - a[0], 2))); }, b.quadrant = function (a, b) { return d(a, b, (a, b) => (b[0] > a[0] ? b[1] > a[1] ? 2 : 1 : b[0] == a[0] ? b[1] > a[1] ? 2 : 1 : b[1] > a[1] ? 3 : 4)); }),
    g = (b.theta = function (a, b) {
      return d(a, b, (a, b) => {
        let c = e(a, b),
          d = Math.atan(c),
          g = f(a, b); return (g == 4 || g == 3) && (d += Math.PI), d < 0 && (d += 2 * Math.PI), d;
      });
    }, b.intersects = function (a, b) {
        let c = a.x,
          d = a.x + a.w,
          e = a.y,
          f = a.y + a.h,
          g = b.x,
          h = b.x + b.w,
          i = b.y,
          j = b.y + b.h; return g >= c && d >= g && i >= e && f >= i || h >= c && d >= h && i >= e && f >= i || g >= c && d >= g && j >= e && f >= j || h >= c && d >= g && j >= e && f >= j || c >= g && h >= c && e >= i && j >= e || d >= g && h >= d && e >= i && j >= e || c >= g && h >= c && f >= i && j >= f || d >= g && h >= c && f >= i && j >= f;
      }, b.encloses = function (a, b, c) {
        let d = a.x,
          e = a.x + a.w,
          f = a.y,
          g = a.y + a.h,
          h = b.x,
          i = b.x + b.w,
          j = b.y,
          k = b.y + b.h,
          l = function (a, b, d, e) { return c ? b >= a && d >= e : b > a && d > e; }; return l(d, h, e, i) && l(f, j, g, k);
      }, [null, [1, -1], [1, 1], [-1, 1], [-1, -1]]),
    h = [null, [-1, -1], [-1, 1], [1, 1], [1, -1]]; b.pointOnLine = function (a, b, c) {
    let d = e(a, b),
      i = f(a, b),
      j = c > 0 ? g[i] : h[i],
      k = Math.atan(d),
      l = Math.abs(c * Math.sin(k)) * j[1],
      m = Math.abs(c * Math.cos(k)) * j[0]; return { x: a.x + m, y: a.y + l };
  }, b.perpendicularLineTo = function (a, b, c) {
    let d = e(a, b),
      f = Math.atan(-1 / d),
      g = c / 2 * Math.sin(f),
      h = c / 2 * Math.cos(f); return [{ x: b.x + h, y: b.y + g }, { x: b.x - h, y: b.y - g }];
  };
}.call(typeof window !== 'undefined' ? window : this), function () {
  var a = this,
    b = { android: navigator.userAgent.toLowerCase().indexOf('android') > -1 },
    c = function (a, b, c) { c = c || a.parentNode; for (let d = c.querySelectorAll(b), e = 0; e < d.length; e++) if (d[e] === a) return !0; return !1; },
    d = function (a) { return typeof a === 'string' || a.constructor === String ? document.getElementById(a) : a; },
    e = function (a) { return a.srcElement || a.target; },
    f = function (a, b, c, d) {
      if (d) {
        if (typeof a.path !== 'undefined' && a.path.indexOf) return { path: a.path, end: a.path.indexOf(c) }; var e = { path: [], end: -1 },
          f = function (a) { e.path.push(a), a === c ? e.end = e.path.length - 1 : a.parentNode != null && f(a.parentNode); }; return f(b), e;
      } return { path: [b], end: 1 };
    },
    g = function (a, b) { for (var c = 0, d = a.length; d > c && a[c] != b; c++);c < a.length && a.splice(c, 1); },
    h = 1,
    i = function (a, b, c) { const d = h++; return a.__ta = a.__ta || {}, a.__ta[b] = a.__ta[b] || {}, a.__ta[b][d] = c, c.__tauid = d, d; },
    j = function (a, b, c) { if (a.__ta && a.__ta[b] && delete a.__ta[b][c.__tauid], c.__taExtra) { for (let d = 0; d < c.__taExtra.length; d++)F(a, c.__taExtra[d][0], c.__taExtra[d][1]); c.__taExtra.length = 0; }c.__taUnstore && c.__taUnstore(); },
    k = function (a, b, d, g) {
      if (a == null) return d; var h = a.split(','),
        i = function (g) {
          i.__tauid = d.__tauid; let j = e(g),
            k = j,
            l = f(g, j, b, a != null); if (l.end != -1) for (let m = 0; m < l.end; m++) { k = l.path[m]; for (let n = 0; n < h.length; n++)c(k, h[n], b) && d.apply(k, arguments); }
        }; return l(d, g, i), i;
    },
    l = function (a, b, c) { a.__taExtra = a.__taExtra || [], a.__taExtra.push([b, c]); },
    m = function (a, b, c, d) { if (s && u[b]) { const e = k(d, a, c, u[b]); E(a, u[b], e, c); }b === 'focus' && a.getAttribute('tabindex') == null && a.setAttribute('tabindex', '1'), E(a, b, k(d, a, c, b), c); },
    n = function (a, b, c, d) {
      if (a.__taSmartClicks == null) {
        let f = function (b) { a.__tad = y(b); },
          h = function (b) { a.__tau = y(b); },
          i = function (b) { if (a.__tad && a.__tau && a.__tad[0] === a.__tau[0] && a.__tad[1] === a.__tau[1]) for (let c = 0; c < a.__taSmartClicks.length; c++)a.__taSmartClicks[c].apply(e(b), [b]); }; m(a, 'mousedown', f, d), m(a, 'mouseup', h, d), m(a, 'click', i, d), a.__taSmartClicks = [];
      }a.__taSmartClicks.push(c), c.__taUnstore = function () { g(a.__taSmartClicks, c); };
    },
    o = { tap: { touches: 1, taps: 1 }, dbltap: { touches: 1, taps: 2 }, contextmenu: { touches: 2, taps: 1 } },
    p = function (a, b) {
      return function (d, h, i, j) {
        if (h == 'contextmenu' && t)m(d, h, i, j); else {
          if (d.__taTapHandler == null) {
            var k = d.__taTapHandler = {
                tap: [], dbltap: [], contextmenu: [], down: !1, taps: 0, downSelectors: []
              },
              l = function (g) { for (let h = e(g), i = f(g, h, d, j != null), l = !1, m = 0; m < i.end; m++) { if (l) return; h = i.path[m]; for (let n = 0; n < k.downSelectors.length; n++) if (k.downSelectors[n] == null || c(h, k.downSelectors[n], d)) { k.down = !0, setTimeout(p, a), setTimeout(q, b), l = !0; break; } } },
              n = function (a) {
                if (k.down) {
                  let b,
                    g,
                    h = e(a); k.taps++; const i = D(a); for (const j in o) if (o.hasOwnProperty(j)) { const l = o[j]; if (l.touches === i && (l.taps === 1 || l.taps === k.taps)) for (let m = 0; m < k[j].length; m++) { g = f(a, h, d, k[j][m][1] != null); for (let n = 0; n < g.end; n++) if (b = g.path[n], k[j][m][1] == null || c(b, k[j][m][1], d)) { k[j][m][0].apply(b, [a]); break; } } }
                }
              },
              p = function () { k.down = !1; },
              q = function () { k.taps = 0; }; m(d, 'mousedown', l), m(d, 'mouseup', n);
          }d.__taTapHandler.downSelectors.push(j), d.__taTapHandler[h].push([i, j]), i.__taUnstore = function () { g(d.__taTapHandler[h], i); };
        }
      };
    },
    q = function (a, b, c, d) { for (const e in c.__tamee[a])c.__tamee[a].hasOwnProperty(e) && c.__tamee[a][e].apply(d, [b]); },
    r = function () {
      const a = []; return function (b, d, f, g) {
        if (!b.__tamee) {
          b.__tamee = { over: !1, mouseenter: [], mouseexit: [] }; let h = function (d) { const f = e(d); (g == null && f == b && !b.__tamee.over || c(f, g, b) && (f.__tamee == null || !f.__tamee.over)) && (q('mouseenter', d, b, f), f.__tamee = f.__tamee || {}, f.__tamee.over = !0, a.push(f)); },
            j = function (d) { for (let f = e(d), g = 0; g < a.length; g++)f != a[g] || c(d.relatedTarget || d.toElement, '*', f) || (f.__tamee.over = !1, a.splice(g, 1), q('mouseexit', d, b, f)); }; E(b, 'mouseover', k(g, b, h, 'mouseover'), h), E(b, 'mouseout', k(g, b, j, 'mouseout'), j);
        }f.__taUnstore = function () { delete b.__tamee[d][f.__tauid]; }, i(b, d, f), b.__tamee[d][f.__tauid] = f;
      };
    },
    s = 'ontouchstart' in document.documentElement,
    t = 'onmousedown' in document.documentElement,
    u = { mousedown: 'touchstart', mouseup: 'touchend', mousemove: 'touchmove' },
    v = (function () {
      let a = -1; if (navigator.appName == 'Microsoft Internet Explorer') {
        let b = navigator.userAgent,
          c = new RegExp('MSIE ([0-9]{1,}[.0-9]{0,})'); c.exec(b) != null && (a = parseFloat(RegExp.$1));
      } return a;
    }()),
    w = v > -1 && v < 9,
    x = function (a, b) {
      if (a == null) return [0, 0]; let c = C(a),
        d = B(c, 0); return [d[`${b}X`], d[`${b}Y`]];
    },
    y = function (a) { return a == null ? [0, 0] : w ? [a.clientX + document.documentElement.scrollLeft, a.clientY + document.documentElement.scrollTop] : x(a, 'page'); },
    z = function (a) { return x(a, 'screen'); },
    A = function (a) { return x(a, 'client'); },
    B = function (a, b) { return a.item ? a.item(b) : a[b]; },
    C = function (a) { return a.touches && a.touches.length > 0 ? a.touches : a.changedTouches && a.changedTouches.length > 0 ? a.changedTouches : a.targetTouches && a.targetTouches.length > 0 ? a.targetTouches : [a]; },
    D = function (a) { return C(a).length; },
    E = function (a, b, c, d) { if (i(a, b, c), d.__tauid = c.__tauid, a.addEventListener)a.addEventListener(b, c, !1); else if (a.attachEvent) { const e = b + c.__tauid; a[`e${e}`] = c, a[e] = function () { a[`e${e}`] && a[`e${e}`](window.event); }, a.attachEvent(`on${b}`, a[e]); } },
    F = function (a, b, c) { c != null && G(a, function () { const e = d(this); if (j(e, b, c), c.__tauid != null) if (e.removeEventListener)e.removeEventListener(b, c, !1), s && u[b] && e.removeEventListener(u[b], c, !1); else if (this.detachEvent) { const f = b + c.__tauid; e[f] && e.detachEvent(`on${b}`, e[f]), e[f] = null, e[`e${f}`] = null; }c.__taTouchProxy && F(a, c.__taTouchProxy[1], c.__taTouchProxy[0]); }); },
    G = function (a, b) { if (a != null) { a = typeof Window !== 'undefined' && typeof a.top !== 'unknown' && a == a.top ? [a] : typeof a !== 'string' && a.tagName == null && a.length != null ? a : typeof a === 'string' ? document.querySelectorAll(a) : [a]; for (let c = 0; c < a.length; c++)b.apply(a[c]); } }; a.Mottle = function (a) {
    a = a || {}; let c = a.clickThreshold || 250,
      e = a.dblClickThreshold || 450,
      f = new r(),
      g = new p(c, e),
      h = a.smartClicks,
      i = function (a, b, c, e) { c != null && G(a, function () { const a = d(this); h && b === 'click' ? n(a, b, c, e) : b === 'tap' || b === 'dbltap' || b === 'contextmenu' ? g(a, b, c, e) : b === 'mouseenter' || b == 'mouseexit' ? f(a, b, c, e) : m(a, b, c, e); }); }; this.remove = function (a) { return G(a, function () { const a = d(this); if (a.__ta) for (const b in a.__ta) if (a.__ta.hasOwnProperty(b)) for (const c in a.__ta[b])a.__ta[b].hasOwnProperty(c) && F(a, b, a.__ta[b][c]); a.parentNode && a.parentNode.removeChild(a); }), this; }, this.on = function () {
      let a = arguments[0],
        b = arguments.length == 4 ? arguments[2] : null,
        c = arguments[1],
        d = arguments[arguments.length - 1]; return i(a, c, d, b), this;
    }, this.off = function (a, b, c) { return F(a, b, c), this; }, this.trigger = function (a, c, e, f) {
      let g = t && (typeof MouseEvent === 'undefined' || e == null || e.constructor === MouseEvent),
        h = s && !t && u[c] ? u[c] : c,
        i = !(s && !t && u[c]),
        j = y(e),
        k = z(e),
        l = A(e); return G(a, function () {
        let a,
          m = d(this); e = e || {
          screenX: k[0], screenY: k[1], clientX: l[0], clientY: l[1]
        }; let n = function (a) { f && (a.payload = f); },
          o = {
            TouchEvent(a) {
              let b = document.createTouch(window, m, 0, j[0], j[1], k[0], k[1], l[0], l[1], 0, 0, 0, 0),
                c = document.createTouchList(b),
                d = document.createTouchList(b),
                e = document.createTouchList(b); a.initTouchEvent(h, !0, !0, window, null, k[0], k[1], l[0], l[1], !1, !1, !1, !1, c, d, e, 1, 0);
            },
            MouseEvents(a) { if (a.initMouseEvent(h, !0, !0, window, 0, k[0], k[1], l[0], l[1], !1, !1, !1, !1, 1, m), b.android) { const c = document.createTouch(window, m, 0, j[0], j[1], k[0], k[1], l[0], l[1], 0, 0, 0, 0); a.touches = a.targetTouches = a.changedTouches = document.createTouchList(c); } }
          }; if (document.createEvent) {
          let p = !i && !g && s && u[c] && !b.android,
            q = p ? 'TouchEvent' : 'MouseEvents'; a = document.createEvent(q), o[q](a), n(a), m.dispatchEvent(a);
        } else document.createEventObject && (a = document.createEventObject(), a.eventType = a.eventName = h, a.screenX = k[0], a.screenY = k[1], a.clientX = l[0], a.clientY = l[1], n(a), m.fireEvent(`on${h}`, a));
      }), this;
    };
  }, a.Mottle.consume = function (a, b) { a.stopPropagation ? a.stopPropagation() : a.returnValue = !1, !b && a.preventDefault && a.preventDefault(); }, a.Mottle.pageLocation = y, a.Mottle.setForceTouchEvents = function (a) { s = a; }, a.Mottle.setForceMouseEvents = function (a) { t = a; }, a.Mottle.version = '0.8.0', typeof exports !== 'undefined' && (exports.Mottle = a.Mottle);
}.call(typeof window === 'undefined' ? this : window), function () {
  var a = this,
    b = function (a, b, c) { return a.indexOf(b) === -1 ? (c ? a.unshift(b) : a.push(b), !0) : !1; },
    c = function (a, b) { const c = a.indexOf(b); c != -1 && a.splice(c, 1); },
    d = function (a, b) { for (var c = [], d = 0; d < a.length; d++)b.indexOf(a[d]) == -1 && c.push(a[d]); return c; },
    e = function (a) { return a == null ? !1 : typeof a === 'string' || a.constructor == String; },
    f = function (a) {
      let b = a.getBoundingClientRect(),
        c = document.body,
        d = document.documentElement,
        e = window.pageYOffset || d.scrollTop || c.scrollTop,
        f = window.pageXOffset || d.scrollLeft || c.scrollLeft,
        g = d.clientTop || c.clientTop || 0,
        h = d.clientLeft || c.clientLeft || 0,
        i = b.top + e - g,
        j = b.left + f - h; return { top: Math.round(i), left: Math.round(j) };
    },
    g = function (a, b, c) { c = c || a.parentNode; for (let d = c.querySelectorAll(b), e = 0; e < d.length; e++) if (d[e] === a) return !0; return !1; },
    h = (function () {
      let a = -1; if (navigator.appName == 'Microsoft Internet Explorer') {
        let b = navigator.userAgent,
          c = new RegExp('MSIE ([0-9]{1,}[.0-9]{0,})'); c.exec(b) != null && (a = parseFloat(RegExp.$1));
      } return a;
    }()),
    i = 10,
    j = 10,
    k = h > -1 && h < 9,
    l = h == 9,
    m = function (a) {
      if (k) return [a.clientX + document.documentElement.scrollLeft, a.clientY + document.documentElement.scrollTop]; let b = o(a),
        c = n(b, 0); return l ? [c.pageX || c.clientX, c.pageY || c.clientY] : [c.pageX, c.pageY];
    },
    n = function (a, b) { return a.item ? a.item(b) : a[b]; },
    o = function (a) { return a.touches && a.touches.length > 0 ? a.touches : a.changedTouches && a.changedTouches.length > 0 ? a.changedTouches : a.targetTouches && a.targetTouches.length > 0 ? a.targetTouches : [a]; },
    p = {
      draggable: 'katavorio-draggable', droppable: 'katavorio-droppable', drag: 'katavorio-drag', selected: 'katavorio-drag-selected', active: 'katavorio-drag-active', hover: 'katavorio-drag-hover', noSelect: 'katavorio-drag-no-select', ghostProxy: 'katavorio-ghost-proxy'
    },
    q = 'katavorio-drag-scope',
    r = ['stop', 'start', 'drag', 'drop', 'over', 'out', 'beforeStart'],
    s = function () {},
    t = function () { return !0; },
    u = function (a, b, c) { for (let d = 0; d < a.length; d++)a[d] != c && b(a[d]); },
    v = function (a, b, c, d) { u(a, (a) => { a.setActive(b), b && a.updatePosition(), c && a.setHover(d, b); }); },
    w = function (a, b) { if (a != null) { a = e(a) || a.tagName != null || a.length == null ? [a] : a; for (let c = 0; c < a.length; c++)b.apply(a[c], [a[c]]); } },
    x = function (a) { a.stopPropagation ? (a.stopPropagation(), a.preventDefault()) : a.returnValue = !1; },
    y = 'input,textarea,select,button,option',
    z = function (a, b, c) { const d = a.srcElement || a.target; return !g(d, c.getInputFilterSelector(), b); },
    A = function (a, b, c, d) { this.params = b || {}, this.el = a, this.params.addClass(this.el, this._class), this.uuid = F(); let e = !0; return this.setEnabled = function (a) { e = a; }, this.isEnabled = function () { return e; }, this.toggleEnabled = function () { e = !e; }, this.setScope = function (a) { this.scopes = a ? a.split(/\s+/) : [d]; }, this.addScope = function (a) { const b = {}; w(this.scopes, (a) => { b[a] = !0; }), w(a ? a.split(/\s+/) : [], (a) => { b[a] = !0; }), this.scopes = []; for (const c in b) this.scopes.push(c); }, this.removeScope = function (a) { const b = {}; w(this.scopes, (a) => { b[a] = !0; }), w(a ? a.split(/\s+/) : [], (a) => { delete b[a]; }), this.scopes = []; for (const c in b) this.scopes.push(c); }, this.toggleScope = function (a) { const b = {}; w(this.scopes, (a) => { b[a] = !0; }), w(a ? a.split(/\s+/) : [], (a) => { b[a] ? delete b[a] : b[a] = !0; }), this.scopes = []; for (const c in b) this.scopes.push(c); }, this.setScope(b.scope), this.k = b.katavorio, b.katavorio; },
    B = function () { return !0; },
    C = function () { return !1; },
    D = function (a, b, c) {
      this._class = c.draggable; const d = A.apply(this, arguments); this.rightButtonCanDrag = this.params.rightButtonCanDrag; let h = [0, 0],
        k = null,
        l = null,
        n = [0, 0],
        o = !1,
        q = this.params.consumeStartEvent !== !1,
        r = this.el,
        s = this.params.clone,
        u = (this.params.scroll, b.multipleDrop !== !1),
        w = !1,
        y = b.ghostProxy === !0 ? B : b.ghostProxy && typeof b.ghostProxy === 'function' ? b.ghostProxy : C,
        D = function (a) { return a.cloneNode(!0); },
        E = b.snapThreshold,
        H = function (a, b, c, d, e) {
          let f = Math.floor(a[0] / b),
            g = b * f,
            h = g + b,
            i = Math.abs(a[0] - g) <= d ? g : Math.abs(h - a[0]) <= d ? h : a[0],
            j = Math.floor(a[1] / c),
            k = c * j,
            l = k + c,
            m = Math.abs(a[1] - k) <= e ? k : Math.abs(l - a[1]) <= e ? l : a[1]; return [i, m];
        }; this.posses = [], this.posseRoles = {}, this.toGrid = function (a) {
        if (this.params.grid == null) return a; let b = this.params.grid ? this.params.grid[0] / 2 : E || i / 2,
          c = this.params.grid ? this.params.grid[1] / 2 : E || j / 2; return H(a, this.params.grid[0], this.params.grid[1], b, c);
      }, this.snap = function (a, b) {
        if (r != null) {
          a = a || (this.params.grid ? this.params.grid[0] : i), b = b || (this.params.grid ? this.params.grid[1] : j); let c = this.params.getPosition(r),
            d = this.params.grid ? this.params.grid[0] / 2 : E,
            e = this.params.grid ? this.params.grid[1] / 2 : E; this.params.setPosition(r, H(c, a, b, d, e));
        }
      }, this.setUseGhostProxy = function (a) { y = a ? B : C; }; let I,
        J = function (a) { return b.allowNegative === !1 ? [Math.max(0, a[0]), Math.max(0, a[1])] : a; },
        K = function (a) { I = typeof a === 'function' ? a : a ? function (a) { return J([Math.max(0, Math.min(Q.w - this.size[0], a[0])), Math.max(0, Math.min(Q.h - this.size[1], a[1]))]); }.bind(this) : function (a) { return J(a); }; }.bind(this); K(typeof this.params.constrain === 'function' ? this.params.constrain : this.params.constrain || this.params.containment), this.setConstrain = function (a) { K(a); }; let L; this.setRevert = function (a) { L = a; }; let M = function (a) { return typeof a === 'function' ? (a._katavorioId = F(), a._katavorioId) : a; },
        N = {},
        O = function (a) {
          for (const b in N) {
            let c = N[b],
              d = c[0](a); if (c[1] && (d = !d), !d) return !1;
          } return !0;
        },
        P = this.setFilter = function (b, c) {
          if (b) {
            const d = M(b); N[d] = [function (c) {
              let d,
                f = c.srcElement || c.target; return e(b) ? d = g(f, b, a) : typeof b === 'function' && (d = b(c, a)), d;
            }, c !== !1];
          }
        }; this.addFilter = P, this.removeFilter = function (a) { const b = typeof a === 'function' ? a._katavorioId : a; delete N[b]; }, this.clearAllFilters = function () { N = {}; }, this.canDrag = this.params.canDrag || t; let Q,
        R = [],
        S = []; this.downListener = function (a) {
        const b = this.rightButtonCanDrag || a.which !== 3 && a.button !== 2; if (b && this.isEnabled() && this.canDrag()) {
          const e = O(a) && z(a, this.el, this.k); if (e) {
            if (s) { r = this.el.cloneNode(!0), r.setAttribute('id', null), r.style.position = 'absolute'; const g = f(this.el); r.style.left = `${g.left}px`, r.style.top = `${g.top}px`, document.body.appendChild(r); } else r = this.el; q && x(a), h = m(a), this.params.bind(document, 'mousemove', this.moveListener), this.params.bind(document, 'mouseup', this.upListener), d.markSelection(this), d.markPosses(this), this.params.addClass(document.body, c.noSelect), U('beforeStart', {
              el: this.el, pos: k, e: a, drag: this
            });
          } else this.params.consumeFilteredEvents && x(a);
        }
      }.bind(this), this.moveListener = function (a) {
        if (h) {
          if (!o) {
            const b = U('start', {
              el: this.el, pos: k, e: a, drag: this
            }); if (b !== !1) { if (!h) return; this.mark(!0), o = !0; } else this.abort();
          } if (h) {
            S.length = 0; let c = m(a),
              e = c[0] - h[0],
              f = c[1] - h[1],
              g = this.params.ignoreZoom ? 1 : d.getZoom(); e /= g, f /= g, this.moveBy(e, f, a), d.updateSelection(e, f, this), d.updatePosses(e, f, this);
          }
        }
      }.bind(this), this.upListener = function (a) { h && (h = null, this.params.unbind(document, 'mousemove', this.moveListener), this.params.unbind(document, 'mouseup', this.upListener), this.params.removeClass(document.body, c.noSelect), this.unmark(a), d.unmarkSelection(this, a), d.unmarkPosses(this, a), this.stop(a), d.notifySelectionDragStop(this, a), d.notifyPosseDragStop(this, a), o = !1, s && (r && r.parentNode && r.parentNode.removeChild(r), r = null), S.length = 0, L && L(this.el, this.params.getPosition(this.el)) === !0 && (this.params.setPosition(this.el, k), U('revert', this.el))); }.bind(this), this.getFilters = function () { return N; }, this.abort = function () { h != null && this.upListener(); }, this.getDragElement = function () { return r || this.el; }; const T = {
        start: [], drag: [], stop: [], over: [], out: [], beforeStart: [], revert: []
      }; b.events.start && T.start.push(b.events.start), b.events.beforeStart && T.beforeStart.push(b.events.beforeStart), b.events.stop && T.stop.push(b.events.stop), b.events.drag && T.drag.push(b.events.drag), b.events.revert && T.revert.push(b.events.revert), this.on = function (a, b) { T[a] && T[a].push(b); }, this.off = function (a, b) { if (T[a]) { for (var c = [], d = 0; d < T[a].length; d++)T[a][d] !== b && c.push(T[a][d]); T[a] = c; } }; var U = function (a, b) { let c = null; if (T[a]) for (let d = 0; d < T[a].length; d++) try { const e = T[a][d](b); e != null && (c = e); } catch (f) {} return c; }; this.notifyStart = function (a) {
        U('start', {
          el: this.el, pos: this.params.getPosition(r), e: a, drag: this
        });
      }, this.stop = function (a, b) {
        if (b || o) {
          let c = [],
            e = d.getSelection(),
            f = this.params.getPosition(r); if (e.length > 1) for (let g = 0; g < e.length; g++) { const h = this.params.getPosition(e[g].el); c.push([e[g].el, { left: h[0], top: h[1] }, e[g]]); } else c.push([r, { left: f[0], top: f[1] }, this]); U('stop', {
            el: r, pos: V || f, finalPos: f, e: a, drag: this, selection: c
          });
        }
      }, this.mark = function (a) { k = this.params.getPosition(r), l = this.params.getPosition(r, !0), n = [l[0] - k[0], l[1] - k[1]], this.size = this.params.getSize(r), R = d.getMatchingDroppables(this), v(R, !0, !1, this), this.params.addClass(r, this.params.dragClass || c.drag); let b; b = this.params.getConstrainingRectangle ? this.params.getConstrainingRectangle(r) : this.params.getSize(r.parentNode), Q = { w: b[0], h: b[1] }, a && d.notifySelectionDragStart(this); }; let V; this.unmark = function (a, d) { if (v(R, !1, !0, this), w && y(this.el) ? (V = [r.offsetLeft, r.offsetTop], this.el.parentNode.removeChild(r), r = this.el) : V = null, this.params.removeClass(r, this.params.dragClass || c.drag), R.length = 0, w = !1, !d) { S.length > 0 && V && b.setPosition(this.el, V), S.sort(G); for (let e = 0; e < S.length; e++) { const f = S[e].drop(this, a); if (f === !0) break; } } }, this.moveBy = function (a, c, d) {
        S.length = 0; let e = this.toGrid([k[0] + a, k[1] + c]),
          f = I(e, r); if (y(this.el)) if (e[0] != f[0] || e[1] != f[1]) { if (!w) { const g = D(this.el); b.addClass(g, p.ghostProxy), this.el.parentNode.appendChild(g), r = g, w = !0; }f = e; } else w && (this.el.parentNode.removeChild(r), r = this.el, w = !1); let h = {
            x: f[0], y: f[1], w: this.size[0], h: this.size[1]
          },
          i = {
            x: h.x + n[0], y: h.y + n[1], w: h.w, h: h.h
          },
          j = null; this.params.setPosition(r, f); for (let l = 0; l < R.length; l++) {
          const m = {
            x: R[l].pagePosition[0], y: R[l].pagePosition[1], w: R[l].size[0], h: R[l].size[1]
          }; this.params.intersects(i, m) && (u || j == null || j == R[l].el) && R[l].canDrop(this) ? (j || (j = R[l].el), S.push(R[l]), R[l].setHover(this, !0, d)) : R[l].isHover() && R[l].setHover(this, !1, d);
        }U('drag', {
          el: this.el, pos: f, e: d, drag: this
        });
      }, this.destroy = function () { this.params.unbind(this.el, 'mousedown', this.downListener), this.params.unbind(document, 'mousemove', this.moveListener), this.params.unbind(document, 'mouseup', this.upListener), this.downListener = null, this.upListener = null, this.moveListener = null; }, this.params.bind(this.el, 'mousedown', this.downListener), this.params.handle ? P(this.params.handle, !1) : P(this.params.filter, this.params.filterExclude);
    },
    E = function (a, b, c) {
      this._class = c.droppable, this.params = b || {}, this.rank = b.rank || 0, this._activeClass = this.params.activeClass || c.active, this._hoverClass = this.params.hoverClass || c.hover, A.apply(this, arguments); let d = !1; this.allowLoopback = this.params.allowLoopback !== !1, this.setActive = function (a) { this.params[a ? 'addClass' : 'removeClass'](this.el, this._activeClass); }, this.updatePosition = function () { this.position = this.params.getPosition(this.el), this.pagePosition = this.params.getPosition(this.el, !0), this.size = this.params.getSize(this.el); }, this.canDrop = this.params.canDrop || function () { return !0; }, this.isHover = function () { return d; }, this.setHover = function (a, b, c) {
        (b || this.el._katavorioDragHover == null || this.el._katavorioDragHover == a.el._katavorio) && (this.params[b ? 'addClass' : 'removeClass'](this.el, this._hoverClass), this.el._katavorioDragHover = b ? a.el._katavorio : null, d !== b && this.params.events[b ? 'over' : 'out']({
          el: this.el, e: c, drag: a, drop: this
        }), d = b);
      }, this.drop = function (a, b) { return this.params.events.drop({ drag: a, e: b, drop: this }); }, this.destroy = function () { this._class = null, this._activeClass = null, this._hoverClass = null, d = null; };
    },
    F = function () {
      return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, (a) => {
        let b = 0 | 16 * Math.random(),
          c = a == 'x' ? b : 8 | 3 & b; return c.toString(16);
      });
    },
    G = function (a, b) { return a.rank < b.rank ? 1 : a.rank > b.rank ? -1 : 0; },
    H = function (a) { return a == null ? null : (a = typeof a === 'string' || a.constructor == String ? document.getElementById(a) : a, a == null ? null : (a._katavorio = a._katavorio || F(), a)); }; a.Katavorio = function (a) {
    let f = [],
      g = {}; this._dragsByScope = {}, this._dropsByScope = {}; let h = 1,
      i = function (a, b) { w(a, (a) => { for (let c = 0; c < a.scopes.length; c++)b[a.scopes[c]] = b[a.scopes[c]] || [], b[a.scopes[c]].push(a); }); },
      j = function (b, c) { let d = 0; return w(b, (b) => { for (let e = 0; e < b.scopes.length; e++) if (c[b.scopes[e]]) { const f = a.indexOf(c[b.scopes[e]], b); f != -1 && (c[b.scopes[e]].splice(f, 1), d++); } }), d > 0; },
      k = (this.getMatchingDroppables = function (a) { for (var b = [], c = {}, d = 0; d < a.scopes.length; d++) { const e = this._dropsByScope[a.scopes[d]]; if (e) for (let f = 0; f < e.length; f++)!e[f].canDrop(a) || c[e[f].uuid] || !e[f].allowLoopback && e[f].el === a.el || (c[e[f].uuid] = !0, b.push(e[f])); } return b.sort(G), b; }, function (b) {
        b = b || {}; let c,
          d = { events: {} }; for (c in a)d[c] = a[c]; for (c in b)d[c] = b[c]; for (c = 0; c < r.length; c++)d.events[r[c]] = b[r[c]] || s; return d.katavorio = this, d;
      }.bind(this)),
      l = function (a, b) { for (let c = 0; c < r.length; c++)b[r[c]] && a.on(r[c], b[r[c]]); },
      m = {},
      n = a.css || {},
      o = a.scope || q; for (var t in p)m[t] = p[t]; for (var t in n)m[t] = n[t]; let v = a.inputFilterSelector || y; this.getInputFilterSelector = function () { return v; }, this.setInputFilterSelector = function (a) { return v = a, this; }, this.draggable = function (b, c) { const d = []; return w(b, (b) => { if (b = H(b), b != null) if (b._katavorioDrag == null) { const e = k(c); b._katavorioDrag = new D(b, e, m, o), i(b._katavorioDrag, this._dragsByScope), d.push(b._katavorioDrag), a.addClass(b, m.draggable); } else l(b._katavorioDrag, c); }), d; }, this.droppable = function (b, c) { const d = []; return w(b, (b) => { if (b = H(b), b != null) { const e = new E(b, k(c), m, o); b._katavorioDrop = b._katavorioDrop || [], b._katavorioDrop.push(e), i(e, this._dropsByScope), d.push(e), a.addClass(b, m.droppable); } }), d; }, this.select = function (b) { return w(b, function () { const b = H(this); b && b._katavorioDrag && (g[b._katavorio] || (f.push(b._katavorioDrag), g[b._katavorio] = [b, f.length - 1], a.addClass(b, m.selected))); }), this; }, this.deselect = function (b) { return w(b, function () { const b = H(this); if (b && b._katavorio) { const c = g[b._katavorio]; if (c) { for (var d = [], e = 0; e < f.length; e++)f[e].el !== b && d.push(f[e]); f = d, delete g[b._katavorio], a.removeClass(b, m.selected); } } }), this; }, this.deselectAll = function () { for (const b in g) { const c = g[b]; a.removeClass(c[0], m.selected); }f.length = 0, g = {}; }, this.markSelection = function (a) { u(f, (a) => { a.mark(); }, a); }, this.markPosses = function (a) { a.posses && w(a.posses, (b) => { a.posseRoles[b] && B[b] && u(B[b].members, (a) => { a.mark(); }, a); }); }, this.unmarkSelection = function (a, b) { u(f, (a) => { a.unmark(b); }, a); }, this.unmarkPosses = function (a, b) { a.posses && w(a.posses, (c) => { a.posseRoles[c] && B[c] && u(B[c].members, (a) => { a.unmark(b, !0); }, a); }); }, this.getSelection = function () { return f.slice(0); }, this.updateSelection = function (a, b, c) { u(f, (c) => { c.moveBy(a, b); }, c); }; const x = function (a, b) { b.posses && w(b.posses, (c) => { b.posseRoles[c] && B[c] && u(B[c].members, (b) => { a(b); }, b); }); }; this.updatePosses = function (a, b, c) { x((c) => { c.moveBy(a, b); }, c); }, this.notifyPosseDragStop = function (a, b) { x((a) => { a.stop(b, !0); }, a); }, this.notifySelectionDragStop = function (a, b) { u(f, (a) => { a.stop(b, !0); }, a); }, this.notifySelectionDragStart = function (a, b) { u(f, (a) => { a.notifyStart(b); }, a); }, this.setZoom = function (a) { h = a; }, this.getZoom = function () { return h; }; const z = function (a, b, c, d) { w(a, (a) => { j(a, c), a[d](b), i(a, c); }); }; w(['set', 'add', 'remove', 'toggle'], (a) => { this[`${a}Scope`] = function (b, c) { z(b._katavorioDrag, c, this._dragsByScope, `${a}Scope`), z(b._katavorioDrop, c, this._dropsByScope, `${a}Scope`); }.bind(this), this[`${a}DragScope`] = function (b, c) { z(b.constructor === D ? b : b._katavorioDrag, c, this._dragsByScope, `${a}Scope`); }.bind(this), this[`${a}DropScope`] = function (b, c) { z(b.constructor === E ? b : b._katavorioDrop, c, this._dropsByScope, `${a}Scope`); }.bind(this); }), this.snapToGrid = function (a, b) { for (const c in this._dragsByScope)u(this._dragsByScope[c], (c) => { c.snap(a, b); }); }, this.getDragsForScope = function (a) { return this._dragsByScope[a]; }, this.getDropsForScope = function (a) { return this._dropsByScope[a]; }; const A = function (a, b, c) { if (a = H(a), a[b]) { const d = f.indexOf(a[b]); d >= 0 && f.splice(d, 1), j(a[b], c) && w(a[b], (a) => { a.destroy(); }), delete a[b]; } }; this.elementRemoved = function (a) { this.destroyDraggable(a), this.destroyDroppable(a); }, this.destroyDraggable = function (a) { A(a, '_katavorioDrag', this._dragsByScope); }, this.destroyDroppable = function (a) { A(a, '_katavorioDrop', this._dropsByScope); }, this.reset = function () { this._dragsByScope = {}, this._dropsByScope = {}, f = [], g = {}, B = {}; }; var B = {},
      C = function (a, c, d) {
        let f = e(c) ? c : c.id,
          g = e(c) ? !0 : c.active !== !1,
          h = B[f] || (function () { const a = { name: f, members: [] }; return B[f] = a, a; }()); return w(a, (a) => { if (a._katavorioDrag) { if (d && a._katavorioDrag.posseRoles[h.name] != null) return; b(h.members, a._katavorioDrag), b(a._katavorioDrag.posses, h.name), a._katavorioDrag.posseRoles[h.name] = g; } }), h;
      }; this.addToPosse = function (a) { for (var b = [], c = 1; c < arguments.length; c++)b.push(C(a, arguments[c])); return b.length == 1 ? b[0] : b; }, this.setPosse = function (a) {
      for (var b = [], c = 1; c < arguments.length; c++)b.push(C(a, arguments[c], !0).name); return w(a, (a) => {
        if (a._katavorioDrag) {
          let c = d(a._katavorioDrag.posses, b),
            e = []; Array.prototype.push.apply(e, a._katavorioDrag.posses); for (let f = 0; f < c.length; f++) this.removeFromPosse(a, c[f]);
        }
      }), b.length == 1 ? b[0] : b;
    }, this.removeFromPosse = function (a, b) { if (arguments.length < 2) throw new TypeError('No posse id provided for remove operation'); for (let d = 1; d < arguments.length; d++)b = arguments[d], w(a, (a) => { if (a._katavorioDrag && a._katavorioDrag.posses) { const d = a._katavorioDrag; w(b, (a) => { c(B[a].members, d), c(d.posses, a), delete d.posseRoles[a]; }); } }); }, this.removeFromAllPosses = function (a) { w(a, (a) => { if (a._katavorioDrag && a._katavorioDrag.posses) { const b = a._katavorioDrag; w(b.posses, (a) => { c(B[a].members, b); }), b.posses.length = 0, b.posseRoles = {}; } }); }, this.setPosseState = function (a, b, c) { const d = B[b]; d && w(a, (a) => { a._katavorioDrag && a._katavorioDrag.posses && (a._katavorioDrag.posseRoles[d.name] = c); }); };
  }, a.Katavorio.version = '0.19.3', typeof exports !== 'undefined' && (exports.Katavorio = a.Katavorio);
}.call(typeof window !== 'undefined' ? window : this), function () {
  let a = function (a) { return Object.prototype.toString.call(a) === '[object Array]'; },
    b = function (a) { return Object.prototype.toString.call(a) === '[object Number]'; },
    c = function (a) { return typeof a === 'string'; },
    d = function (a) { return typeof a === 'boolean'; },
    e = function (a) { return a == null; },
    f = function (a) { return a == null ? !1 : Object.prototype.toString.call(a) === '[object Object]'; },
    g = function (a) { return Object.prototype.toString.call(a) === '[object Date]'; },
    h = function (a) { return Object.prototype.toString.call(a) === '[object Function]'; },
    i = function (a) {
      for (const b in a) if (a.hasOwnProperty(b)) return !1;
      return !0;
    },
    j = this; j.jsPlumbUtil = {
    isArray: a,
    isString: c,
    isBoolean: d,
    isNull: e,
    isObject: f,
    isDate: g,
    isFunction: h,
    isEmpty: i,
    isNumber: b,
    clone(b) { if (c(b)) return `${b}`; if (d(b)) return !!b; if (g(b)) return new Date(b.getTime()); if (h(b)) return b; if (a(b)) { for (var e = [], i = 0; i < b.length; i++)e.push(this.clone(b[i])); return e; } if (f(b)) { const j = {}; for (const k in b)j[k] = this.clone(b[k]); return j; } return b; },
    merge(b, e, g) {
      let h,
        i,
        j = {}; for (g = g || [], i = 0; i < g.length; i++)j[g[i]] = !0; const k = this.clone(b); for (i in e) if (k[i] == null)k[i] = e[i]; else if (c(e[i]) || d(e[i]))j[i] ? (h = [], h.push(...a(k[i]) ? k[i] : [k[i]]), h.push(...a(e[i]) ? e[i] : [e[i]]), k[i] = h) : k[i] = e[i]; else if (a(e[i]))h = [], a(k[i]) && h.push(...k[i]), h.push(...e[i]), k[i] = h; else if (f(e[i])) { f(k[i]) || (k[i] = {}); for (const l in e[i])k[i][l] = e[i][l]; } return k;
    },
    replace(a, b, c) {
      if (a != null) {
        let d = a,
          e = d; return b.replace(/([^\.])+/g, (a, b, d, f) => {
          let g = a.match(/([^\[0-9]+){1}(\[)([0-9+])/),
            h = d + a.length >= f.length,
            i = function () { return e[g[1]] || (function () { return e[g[1]] = [], e[g[1]]; }()); }; if (h)g ? i()[g[3]] = c : e[a] = c; else if (g) { const j = i(); e = j[g[3]] || (function () { return j[g[3]] = {}, j[g[3]]; }()); } else e = e[a] || (function () { return e[a] = {}, e[a]; }());
        }), a;
      }
    },
    functionChain(a, b, c) { for (let d = 0; d < c.length; d++) { const e = c[d][0][c[d][1]].apply(c[d][0], c[d][2]); if (e === b) return e; } return a; },
    populate(b, d, e) {
      var g = function (a) { const b = a.match(/(\${.*?})/g); if (b != null) for (let c = 0; c < b.length; c++) { const e = d[b[c].substring(2, b[c].length - 1)] || ''; e != null && (a = a.replace(b[c], e)); } return a; },
        i = function (b) { if (b != null) { if (c(b)) return g(b); if (!h(b) || e != null && (b.name || '').indexOf(e) !== 0) { if (a(b)) { for (var j = [], k = 0; k < b.length; k++)j.push(i(b[k])); return j; } if (f(b)) { const l = {}; for (const m in b)l[m] = i(b[m]); return l; } return b; } return b(d); } }; return i(b);
    },
    findWithFunction(a, b) { if (a) for (let c = 0; c < a.length; c++) if (b(a[c])) return c; return -1; },
    removeWithFunction(a, b) { const c = j.jsPlumbUtil.findWithFunction(a, b); return c > -1 && a.splice(c, 1), c !== -1; },
    remove(a, b) { const c = a.indexOf(b); return c > -1 && a.splice(c, 1), c !== -1; },
    addWithFunction(a, b, c) { j.jsPlumbUtil.findWithFunction(a, c) === -1 && a.push(b); },
    addToList(a, b, c, d) { let e = a[b]; return e == null && (e = [], a[b] = e), e[d ? 'unshift' : 'push'](c), e; },
    suggest(a, b, c) { return a.indexOf(b) === -1 ? (c ? a.unshift(b) : a.push(b), !0) : !1; },
    extend(b, c) {
      let d; for (c = a(c) ? c : [c], d = 0; d < c.length; d++) for (const e in c[d].prototype)c[d].prototype.hasOwnProperty(e) && (b.prototype[e] = c[d].prototype[e]); let f = function (a, b) { return function () { for (d = 0; d < c.length; d++)c[d].prototype[a] && c[d].prototype[a].apply(this, arguments); return b.apply(this, arguments); }; },
        g = function (a) { for (const c in a)b.prototype[c] = f(c, a[c]); }; if (arguments.length > 2) for (d = 2; d < arguments.length; d++)g(arguments[d]); return b;
    },
    uuid() {
      return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, (a) => {
        let b = 0 | 16 * Math.random(),
          c = a === 'x' ? b : 8 | 3 & b; return c.toString(16);
      });
    },
    logEnabled: !0,
    log() { if (j.jsPlumbUtil.logEnabled && typeof console !== 'undefined') try { const a = arguments[arguments.length - 1]; console.log(a); } catch (b) {} },
    wrap(a, b, c) { return function () { let d = null; try { b != null && (d = b.apply(this, arguments)); } catch (e) { j.jsPlumbUtil.log(`jsPlumb function failed : ${e}`); } if (a != null && (c == null || d !== c)) try { d = a.apply(this, arguments); } catch (e) { j.jsPlumbUtil.log(`wrapped function failed : ${e}`); } return d; }; }
  }, j.jsPlumbUtil.EventGenerator = function () {
    let a = {},
      b = !1,
      c = !1,
      d = { ready: !0 },
      e = []; this.bind = function (b, c, d) { const e = function (b) { j.jsPlumbUtil.addToList(a, b, c, d), c.__jsPlumb = c.__jsPlumb || {}, c.__jsPlumb[j.jsPlumbUtil.uuid()] = b; }; if (typeof b === 'string')e(b); else if (b.length != null) for (let f = 0; f < b.length; f++)e(b[f]); return this; }, this.fire = function (g, h, i) {
      if (c)e.unshift(arguments); else {
        if (c = !0, !b && a[g]) {
          let k = a[g].length,
            l = 0,
            m = !1,
            n = null; if (!this.shouldFireEvent || this.shouldFireEvent(g, h, i)) for (;!m && k > l && n !== !1;) { if (d[g])a[g][l].apply(this, [h, i]); else try { n = a[g][l].apply(this, [h, i]); } catch (o) { j.jsPlumbUtil.log(`jsPlumb: fire failed for event ${g} : ${o}`); }l++, (a == null || a[g] == null) && (m = !0); }
        }c = !1, f();
      } return this;
    }; var f = function () { const a = e.pop(); a && this.fire.apply(this, a); }.bind(this); this.unbind = function (b, c) { if (arguments.length === 0)a = {}; else if (arguments.length === 1) { if (typeof b === 'string') delete a[b]; else if (b.__jsPlumb) { let d; for (const e in b.__jsPlumb)d = b.__jsPlumb[e], j.jsPlumbUtil.remove(a[d] || [], b); } } else arguments.length === 2 && j.jsPlumbUtil.remove(a[b] || [], c); return this; }, this.getListener = function (b) { return a[b]; }, this.setSuspendEvents = function (a) { b = a; }, this.isSuspendEvents = function () { return b; }, this.silently = function (a) { this.setSuspendEvents(!0); try { a(); } catch (b) { j.jsPlumbUtil.log(`Cannot execute silent function ${b}`); } this.setSuspendEvents(!1); }, this.cleanupListeners = function () { for (const b in a)a[b] = null; };
  }, j.jsPlumbUtil.EventGenerator.prototype = { cleanup() { this.cleanupListeners(); } }, typeof exports !== 'undefined' && (exports.jsPlumbUtil = j.jsPlumbUtil);
}.call(typeof window !== 'undefined' ? window : this), function () {
  const a = this; a.jsPlumbUtil.matchesSelector = function (a, b, c) { c = c || a.parentNode; for (let d = c.querySelectorAll(b), e = 0; e < d.length; e++) if (d[e] === a) return !0; return !1; }, a.jsPlumbUtil.consume = function (a, b) { a.stopPropagation ? a.stopPropagation() : a.returnValue = !1, !b && a.preventDefault && a.preventDefault(); }, a.jsPlumbUtil.sizeElement = function (a, b, c, d, e) { a && (a.style.height = `${e}px`, a.height = e, a.style.width = `${d}px`, a.width = d, a.style.left = `${b}px`, a.style.top = `${c}px`); };
}.call(typeof window !== 'undefined' ? window : this), function () {
  let a,
    b = this,
    c = [],
    d = b.jsPlumbUtil,
    e = function () { return `${(new Date()).getTime()}`; },
    f = function (a) { if (a._jsPlumb.paintStyle && a._jsPlumb.hoverPaintStyle) { const b = {}; r.extend(b, a._jsPlumb.paintStyle), r.extend(b, a._jsPlumb.hoverPaintStyle), delete a._jsPlumb.hoverPaintStyle, b.gradient && a._jsPlumb.paintStyle.fill && delete b.gradient, a._jsPlumb.hoverPaintStyle = b; } },
    g = ['tap', 'dbltap', 'click', 'dblclick', 'mouseover', 'mouseout', 'mousemove', 'mousedown', 'mouseup', 'contextmenu'],
    h = function (a, b, c, d) { const e = a.getAttachedElements(); if (e) for (let f = 0, g = e.length; g > f; f++)d && d === e[f] || e[f].setHover(b, !0, c); },
    i = function (a) { return a == null ? null : a.split(' '); },
    j = function (a, b, c) { for (const d in b)a[d] = c; },
    k = function (a, b) { b = d.isArray(b) || b.length != null && !d.isString(b) ? b : [b]; for (let c = 0; c < b.length; c++) try { a.apply(b[c], [b[c]]); } catch (e) { d.log(`.each iteration failed : ${e}`); } },
    l = function (a, b, c) {
      if (a.getDefaultType) {
        let e = a.getTypeDescriptor(),
          f = {},
          g = a.getDefaultType(),
          h = d.merge({}, g); j(f, g, '__default'); for (let i = 0, k = a._jsPlumb.types.length; k > i; i++) { const l = a._jsPlumb.types[i]; if (l !== '__default') { const m = a._jsPlumb.instance.getType(l, e); m != null && (h = d.merge(h, m, ['cssClass']), j(f, m, l)); } }b && (h = d.populate(h, b, '_')), a.applyType(h, c, f), c || a.repaint();
      }
    },
    m = b.jsPlumbUIComponent = function (a) {
      d.EventGenerator.apply(this, arguments); let b = this,
        c = arguments,
        e = b.idPrefix,
        f = e + (new Date()).getTime(); this._jsPlumb = {
        instance: a._jsPlumb, parameters: a.parameters || {}, paintStyle: null, hoverPaintStyle: null, paintStyleInUse: null, hover: !1, beforeDetach: a.beforeDetach, beforeDrop: a.beforeDrop, overlayPlacements: [], hoverClass: a.hoverClass || a._jsPlumb.Defaults.HoverClass, types: [], typeCache: {}
      }, this.cacheTypeItem = function (a, b, c) { this._jsPlumb.typeCache[c] = this._jsPlumb.typeCache[c] || {}, this._jsPlumb.typeCache[c][a] = b; }, this.getCachedTypeItem = function (a, b) { return this._jsPlumb.typeCache[b] ? this._jsPlumb.typeCache[b][a] : null; }, this.getId = function () { return f; }; let g = a.overlays || [],
        h = {}; if (this.defaultOverlayKeys) { for (var i = 0; i < this.defaultOverlayKeys.length; i++)Array.prototype.push.apply(g, this._jsPlumb.instance.Defaults[this.defaultOverlayKeys[i]] || []); for (i = 0; i < g.length; i++) { const j = r.convertToFullOverlaySpec(g[i]); h[j[1].id] = j; } } const k = { overlays: h, parameters: a.parameters || {}, scope: a.scope || this._jsPlumb.instance.getDefaultScope() }; if (this.getDefaultType = function () { return k; }, this.appendToDefaultType = function (a) { for (const b in a)k[b] = a[b]; }, a.events) for (const l in a.events)b.bind(l, a.events[l]); this.clone = function () { const a = Object.create(this.constructor.prototype); return this.constructor.apply(a, c), a; }.bind(this), this.isDetachAllowed = function (a) { let b = !0; if (this._jsPlumb.beforeDetach) try { b = this._jsPlumb.beforeDetach(a); } catch (c) { d.log('jsPlumb: beforeDetach callback failed', c); } return b; }, this.isDropAllowed = function (a, b, c, e, f, g, h) {
        let i = this._jsPlumb.instance.checkCondition('beforeDrop', {
          sourceId: a, targetId: b, scope: c, connection: e, dropEndpoint: f, source: g, target: h
        }); if (this._jsPlumb.beforeDrop) {
          try {
            i = this._jsPlumb.beforeDrop({
              sourceId: a, targetId: b, scope: c, connection: e, dropEndpoint: f, source: g, target: h
            });
          } catch (j) { d.log('jsPlumb: beforeDrop callback failed', j); }
        } return i;
      }; const m = []; this.setListenerComponent = function (a) { for (let b = 0; b < m.length; b++)m[b][3] = a; };
    },
    n = function (a, b) {
      let c = a._jsPlumb.types[b],
        d = a._jsPlumb.instance.getType(c, a.getTypeDescriptor()); d != null && d.cssClass && a.canvas && a._jsPlumb.instance.removeClass(a.canvas, d.cssClass);
    }; d.extend(b.jsPlumbUIComponent, d.EventGenerator, {
    getParameter(a) { return this._jsPlumb.parameters[a]; },
    setParameter(a, b) { this._jsPlumb.parameters[a] = b; },
    getParameters() { return this._jsPlumb.parameters; },
    setParameters(a) { this._jsPlumb.parameters = a; },
    getClass() { return r.getClass(this.canvas); },
    hasClass(a) { return r.hasClass(this.canvas, a); },
    addClass(a) { r.addClass(this.canvas, a); },
    removeClass(a) { r.removeClass(this.canvas, a); },
    updateClasses(a, b) { r.updateClasses(this.canvas, a, b); },
    setType(a, b, c) { this.clearTypes(), this._jsPlumb.types = i(a) || [], l(this, b, c); },
    getType() { return this._jsPlumb.types; },
    reapplyTypes(a, b) { l(this, a, b); },
    hasType(a) { return this._jsPlumb.types.indexOf(a) !== -1; },
    addType(a, b, c) {
      let d = i(a),
        e = !1; if (d != null) { for (let f = 0, g = d.length; g > f; f++) this.hasType(d[f]) || (this._jsPlumb.types.push(d[f]), e = !0); e && l(this, b, c); }
    },
    removeType(a, b, c) {
      let d = i(a),
        e = !1,
        f = function (a) { const b = this._jsPlumb.types.indexOf(a); return b !== -1 ? (n(this, b), this._jsPlumb.types.splice(b, 1), !0) : !1; }.bind(this); if (d != null) { for (let g = 0, h = d.length; h > g; g++)e = f(d[g]) || e; e && l(this, b, c); }
    },
    clearTypes(a, b) { for (let c = this._jsPlumb.types.length, d = 0; c > d; d++)n(this, 0), this._jsPlumb.types.splice(0, 1); l(this, a, b); },
    toggleType(a, b, c) { const d = i(a); if (d != null) { for (let e = 0, f = d.length; f > e; e++) { const g = this._jsPlumb.types.indexOf(d[e]); g !== -1 ? (n(this, g), this._jsPlumb.types.splice(g, 1)) : this._jsPlumb.types.push(d[e]); }l(this, b, c); } },
    applyType(a, b) { if (this.setPaintStyle(a.paintStyle, b), this.setHoverPaintStyle(a.hoverPaintStyle, b), a.parameters) for (const c in a.parameters) this.setParameter(c, a.parameters[c]); this._jsPlumb.paintStyleInUse = this.getPaintStyle(); },
    setPaintStyle(a, b) { this._jsPlumb.paintStyle = a, this._jsPlumb.paintStyleInUse = this._jsPlumb.paintStyle, f(this), b || this.repaint(); },
    getPaintStyle() { return this._jsPlumb.paintStyle; },
    setHoverPaintStyle(a, b) { this._jsPlumb.hoverPaintStyle = a, f(this), b || this.repaint(); },
    getHoverPaintStyle() { return this._jsPlumb.hoverPaintStyle; },
    destroy(a) { (a || this.typeId == null) && (this.cleanupListeners(), this.clone = null, this._jsPlumb = null); },
    isHover() { return this._jsPlumb.hover; },
    setHover(a, b, c) { if (this._jsPlumb && !this._jsPlumb.instance.currentlyDragging && !this._jsPlumb.instance.isHoverSuspended()) { this._jsPlumb.hover = a; const d = a ? 'addClass' : 'removeClass'; this.canvas != null && (this._jsPlumb.instance.hoverClass != null && this._jsPlumb.instance[d](this.canvas, this._jsPlumb.instance.hoverClass), this._jsPlumb.hoverClass != null && this._jsPlumb.instance[d](this.canvas, this._jsPlumb.hoverClass)), this._jsPlumb.hoverPaintStyle != null && (this._jsPlumb.paintStyleInUse = a ? this._jsPlumb.hoverPaintStyle : this._jsPlumb.paintStyle, this._jsPlumb.instance.isSuspendDrawing() || (c = c || e(), this.repaint({ timestamp: c, recalc: !1 }))), this.getAttachedElements && !b && h(this, a, e(), this); } }
  }); let o = 0,
    p = function () { const a = o + 1; return o++, a; },
    q = b.jsPlumbInstance = function (f) {
      this.version = '2.5.7', f && r.extend(this.Defaults, f), this.logEnabled = this.Defaults.LogEnabled, this._connectionTypes = {}, this._endpointTypes = {}, d.EventGenerator.apply(this); let h = this,
        i = p(),
        j = h.bind,
        l = {},
        n = 1,
        o = function (a) { if (a == null) return null; if (a.nodeType === 3 || a.nodeType === 8) return { el: a, text: !0 }; const b = h.getElement(a); return { el: b, id: d.isString(a) && b == null ? a : $(b) }; }; this.getInstanceIndex = function () { return i; }, this.setZoom = function (a, b) { return n = a, h.fire('zoom', n), b && h.repaintEverything(), !0; }, this.getZoom = function () { return n; }; for (const q in this.Defaults)l[q] = this.Defaults[q]; let s,
        t = []; this.unbindContainer = function () { if (s != null && t.length > 0) for (let a = 0; a < t.length; a++)h.off(s, t[a][0], t[a][1]); }, this.setContainer = function (a) {
        this.unbindContainer(), a = this.getElement(a), this.select().each((b) => { b.moveParent(a); }), this.selectEndpoints().each((b) => { b.moveParent(a); }); const b = s; s = a, t.length = 0; for (var c = { endpointclick: 'endpointClick', endpointdblclick: 'endpointDblClick' }, d = function (a, b, d) {
            let e = b.srcElement || b.target,
              f = (e && e.parentNode ? e.parentNode._jsPlumb : null) || (e ? e._jsPlumb : null) || (e && e.parentNode && e.parentNode.parentNode ? e.parentNode.parentNode._jsPlumb : null); if (f) { f.fire(a, f, b); const g = d ? c[d + a] || a : a; h.fire(g, f.component || f, b); }
          }, e = function (a, b, c) { t.push([a, c]), h.on(s, a, b, c); }, f = function (a) { e(a, '.jtk-connector', (b) => { d(a, b); }), e(a, '.jtk-endpoint', (b) => { d(a, b, 'endpoint'); }), e(a, '.jtk-overlay', (b) => { d(a, b); }); }, i = 0; i < g.length; i++)f(g[i]); for (const j in z) { const k = z[j].el; k.parentNode === b && (b.removeChild(k), s.appendChild(k)); }
      }, this.getContainer = function () { return s; }, this.bind = function (a, b) { a === 'ready' && v ? b() : j.apply(h, [a, b]); }, h.importDefaults = function (a) { for (const b in a)h.Defaults[b] = a[b]; return a.Container && h.setContainer(a.Container), h; }, h.restoreDefaults = function () { return h.Defaults = r.extend({}, l), h; }; var u = null,
        v = !1,
        w = [],
        x = {},
        y = {},
        z = {},
        A = {},
        B = {},
        C = {},
        D = !1,
        E = [],
        F = !1,
        G = null,
        H = this.Defaults.Scope,
        I = 1,
        J = function () { return `${I++}`; },
        K = function (a, b) { s ? s.appendChild(a) : b ? this.getElement(b).appendChild(a) : this.appendToRoot(a); }.bind(this),
        L = function (a, b, c, d) {
          if (!F) {
            let f,
              g = $(a),
              i = h.getDragManager(); i && (f = i.getElementsForDraggable(g)), c == null && (c = e()); const j = vb({
              elId: g, offset: b, recalc: !1, timestamp: c
            }); if (f && j && j.o) {
              for (const k in f) {
                vb({
                  elId: f[k].id, offset: { left: j.o.left + f[k].offset.left, top: j.o.top + f[k].offset.top }, recalc: !1, timestamp: c
                });
              }
            } if (h.anchorManager.redraw(g, b, c, null, d), f) for (const l in f)h.anchorManager.redraw(f[l].id, b, c, f[l].offset, d, !0);
          }
        },
        M = function (a) { return y[a]; },
        N = function (a, b, c, e, f) {
          if (!r.headless) {
            const g = b == null ? !1 : b; if (g && r.isDragSupported(a, h)) {
              let i = c || h.Defaults.DragOptions; if (i = r.extend({}, i), r.isAlreadyDraggable(a, h))c.force && h.initDraggable(a, i); else {
                let j = r.dragEvents.drag,
                  k = r.dragEvents.stop,
                  l = r.dragEvents.start,
                  m = !1; ub(e, a), i[l] = d.wrap(i[l], () => h.setHoverSuspended(!0), h.select({ source: a }).addClass(`${h.elementDraggingClass} ${h.sourceElementDraggingClass}`, !0), h.select({ target: a }).addClass(`${h.elementDraggingClass} ${h.targetElementDraggingClass}`, !0), h.setConnectionBeingDragged(!0), i.canDrag ? c.canDrag() : void 0, !1), i[j] = d.wrap(i[j], function () { const b = h.getUIPosition(arguments, h.getZoom()); b != null && (L(a, b, null, !0), m && h.addClass(a, 'jtk-dragged'), m = !0); }), i[k] = d.wrap(i[k], function () { for (var a, b = arguments[0].selection, c = function (b) { b[1] != null && (a = h.getUIPosition([{ el: b[2].el, pos: [b[1].left, b[1].top] }]), L(b[2].el, a)), h.removeClass(b[0], 'jtk-dragged'), h.select({ source: b[2].el }).removeClass(`${h.elementDraggingClass} ${h.sourceElementDraggingClass}`, !0), h.select({ target: b[2].el }).removeClass(`${h.elementDraggingClass} ${h.targetElementDraggingClass}`, !0), h.getDragManager().dragEnded(b[2].el); }, d = 0; d < b.length; d++)c(b[d]); m = !1, h.setHoverSuspended(!1), h.setConnectionBeingDragged(!1); }); const n = $(a); C[n] = !0; const o = C[n]; i.disabled = o == null ? !1 : !o, h.initDraggable(a, i), h.getDragManager().register(a), f && h.fire('elementDraggable', { el: a, options: i });
              }
            }
          }
        },
        O = function (a, b) { for (let c = a.scope.split(/\s/), d = b.scope.split(/\s/), e = 0; e < c.length; e++) for (let f = 0; f < d.length; f++) if (d[f] === c[e]) return !0; return !1; },
        P = function (a, b) { const c = r.extend({}, a); for (const d in b)b[d] && (c[d] = b[d]); return c; },
        Q = function (a, b) {
          let c = r.extend({}, a); if (b && r.extend(c, b), c.source && (c.source.endpoint ? c.sourceEndpoint = c.source : c.source = h.getElement(c.source)), c.target && (c.target.endpoint ? c.targetEndpoint = c.target : c.target = h.getElement(c.target)), a.uuids && (c.sourceEndpoint = M(a.uuids[0]), c.targetEndpoint = M(a.uuids[1])), c.sourceEndpoint && c.sourceEndpoint.isFull()) return d.log(h, 'could not add connection; source endpoint is full'), void 0; if (c.targetEndpoint && c.targetEndpoint.isFull()) return d.log(h, 'could not add connection; target endpoint is full'), void 0; if (!c.type && c.sourceEndpoint && (c.type = c.sourceEndpoint.connectionType), c.sourceEndpoint && c.sourceEndpoint.connectorOverlays) { c.overlays = c.overlays || []; for (let e = 0, f = c.sourceEndpoint.connectorOverlays.length; f > e; e++)c.overlays.push(c.sourceEndpoint.connectorOverlays[e]); }c.sourceEndpoint && c.sourceEndpoint.scope && (c.scope = c.sourceEndpoint.scope), !c['pointer-events'] && c.sourceEndpoint && c.sourceEndpoint.connectorPointerEvents && (c['pointer-events'] = c.sourceEndpoint.connectorPointerEvents); let g = function (a, b, d) {
              return h.addEndpoint(a, P(b, {
                anchor: c.anchors ? c.anchors[d] : c.anchor, endpoint: c.endpoints ? c.endpoints[d] : c.endpoint, paintStyle: c.endpointStyles ? c.endpointStyles[d] : c.endpointStyle, hoverPaintStyle: c.endpointHoverStyles ? c.endpointHoverStyles[d] : c.endpointHoverStyle
              }));
            },
            i = function (a, b, d, e) {
              if (c[a] && !c[a].endpoint && !c[`${a}Endpoint`] && !c.newConnection) {
                let f = $(c[a]),
                  h = d[f]; if (h = h ? h[e] : null) { if (!h.enabled) return !1; const i = h.endpoint != null && h.endpoint._jsPlumb ? h.endpoint : g(c[a], h.def, b); if (i.isFull()) return !1; c[`${a}Endpoint`] = i, !c.scope && h.def.scope && (c.scope = h.def.scope), h.uniqueEndpoint ? h.endpoint ? i.finalEndpoint = h.endpoint : (h.endpoint = i, i.setDeleteOnEmpty(!1)) : i.setDeleteOnEmpty(!0); }
              }
            }; return i('source', 0, this.sourceEndpointDefinitions, c.type || 'default') !== !1 && i('target', 1, this.targetEndpointDefinitions, c.type || 'default') !== !1 ? (c.sourceEndpoint && c.targetEndpoint && (O(c.sourceEndpoint, c.targetEndpoint) || (c = null)), c) : void 0;
        }.bind(h),
        R = function (a) { const b = h.Defaults.ConnectionType || h.getDefaultConnectionType(); a._jsPlumb = h, a.newConnection = R, a.newEndpoint = T, a.endpointsByUUID = y, a.endpointsByElement = x, a.finaliseConnection = S, a.id = `con_${J()}`; const c = new b(a); return c.isDetachable() && (c.endpoints[0].initDraggable('_jsPlumbSource'), c.endpoints[1].initDraggable('_jsPlumbTarget')), c; },
        S = h.finaliseConnection = function (a, b, c, d) {
          if (b = b || {}, a.suspendedEndpoint || w.push(a), a.pending = null, a.endpoints[0].isTemporarySource = !1, d !== !1 && h.anchorManager.newConnection(a), L(a.source), !b.doNotFireConnectionEvent && b.fireEvent !== !1) {
            const e = {
              connection: a, source: a.source, target: a.target, sourceId: a.sourceId, targetId: a.targetId, sourceEndpoint: a.endpoints[0], targetEndpoint: a.endpoints[1]
            }; h.fire('connection', e, c);
          }
        },
        T = function (a, b) {
          let c = h.Defaults.EndpointType || r.Endpoint,
            d = r.extend({}, a); d._jsPlumb = h, d.newConnection = R, d.newEndpoint = T, d.endpointsByUUID = y, d.endpointsByElement = x, d.fireDetachEvent = bb, d.elementId = b || $(d.source); const e = new c(d); return e.id = `ep_${J()}`, ub(d.elementId, d.source), r.headless || h.getDragManager().endpointAdded(d.source, b), e;
        },
        U = function (a, b, c) { const d = x[a]; if (d && d.length) for (let e = 0, f = d.length; f > e; e++) { for (let g = 0, h = d[e].connections.length; h > g; g++) { const i = b(d[e].connections[g]); if (i) return; }c && c(d[e]); } },
        V = function (a, b) { return r.each(a, (a) => { h.isDragSupported(a) && (C[h.getAttribute(a, 'id')] = b, h.setElementDraggable(a, b)); }); },
        W = function (a, b, c) { b = b === 'block'; let d = null; c && (d = function (a) { a.setVisible(b, !0, !0); }); const e = o(a); U(e.id, (a) => { if (b && c) { const d = a.sourceId === e.id ? 1 : 0; a.endpoints[d].isVisible() && a.setVisible(!0); } else a.setVisible(b); }, d); },
        X = function (a) { let b; return r.each(a, (a) => { const c = h.getAttribute(a, 'id'); return b = C[c] == null ? !1 : C[c], b = !b, C[c] = b, h.setDraggable(a, b), b; }), b; },
        Y = function (a, b) { let c = null; b && (c = function (a) { const b = a.isVisible(); a.setVisible(!b); }), U(a, (a) => { const b = a.isVisible(); a.setVisible(!b); }, c); },
        Z = function (a) { const b = A[a]; return b ? { o: b, s: E[a] } : vb({ elId: a }); },
        $ = function (a, b, c) { if (d.isString(a)) return a; if (a == null) return null; let e = h.getAttribute(a, 'id'); return e && e !== 'undefined' || (arguments.length === 2 && void 0 !== arguments[1] ? e = b : (arguments.length === 1 || arguments.length === 3 && !arguments[2]) && (e = `jsPlumb_${i}_${J()}`), c || h.setAttribute(a, 'id', e)), e; }; this.setConnectionBeingDragged = function (a) { D = a; }, this.isConnectionBeingDragged = function () { return D; }, this.getManagedElements = function () { return z; }, this.connectorClass = 'jtk-connector', this.connectorOutlineClass = 'jtk-connector-outline', this.editableConnectorClass = 'jtk-connector-editable', this.connectedClass = 'jtk-connected', this.hoverClass = 'jtk-hover', this.endpointClass = 'jtk-endpoint', this.endpointConnectedClass = 'jtk-endpoint-connected', this.endpointFullClass = 'jtk-endpoint-full', this.endpointDropAllowedClass = 'jtk-endpoint-drop-allowed', this.endpointDropForbiddenClass = 'jtk-endpoint-drop-forbidden', this.overlayClass = 'jtk-overlay', this.draggingClass = 'jtk-dragging', this.elementDraggingClass = 'jtk-element-dragging', this.sourceElementDraggingClass = 'jtk-source-element-dragging', this.targetElementDraggingClass = 'jtk-target-element-dragging', this.endpointAnchorClassPrefix = 'jtk-endpoint-anchor', this.hoverSourceClass = 'jtk-source-hover', this.hoverTargetClass = 'jtk-target-hover', this.dragSelectClass = 'jtk-drag-select', this.Anchors = {}, this.Connectors = { svg: {} }, this.Endpoints = { svg: {} }, this.Overlays = { svg: {} }, this.ConnectorRenderers = {}, this.SVG = 'svg', this.addEndpoint = function (a, b, c) {
        c = c || {}; const e = r.extend({}, c); r.extend(e, b), e.endpoint = e.endpoint || h.Defaults.Endpoint, e.paintStyle = e.paintStyle || h.Defaults.EndpointStyle; for (var f = [], g = d.isArray(a) || a.length != null && !d.isString(a) ? a : [a], i = 0, j = g.length; j > i; i++) {
          e.source = h.getElement(g[i]), sb(e.source); let k = $(e.source),
            l = T(e, k),
            m = ub(k, e.source).info.o; d.addToList(x, k, l), F || l.paint({
            anchorLoc: l.anchor.compute({
              xy: [m.left, m.top], wh: E[k], element: l, timestamp: G
            }),
            timestamp: G
          }), f.push(l);
        } return f.length === 1 ? f[0] : f;
      }, this.addEndpoints = function (a, b, c) { for (var e = [], f = 0, g = b.length; g > f; f++) { const i = h.addEndpoint(a, b[f], c); d.isArray(i) ? Array.prototype.push.apply(e, i) : e.push(i); } return e; }, this.animate = function (a, b, c) {
        if (!this.animationSupported) return !1; c = c || {}; let e = h.getElement(a),
          f = $(e),
          g = r.animEvents.step,
          i = r.animEvents.complete; c[g] = d.wrap(c[g], () => { h.revalidate(f); }), c[i] = d.wrap(c[i], () => { h.revalidate(f); }), h.doAnimate(e, b, c);
      }, this.checkCondition = function (a) {
        let b = h.getListener(a),
          c = !0; if (b && b.length > 0) { const e = Array.prototype.slice.call(arguments, 1); try { for (let f = 0, g = b.length; g > f; f++)c = c && b[f].apply(b[f], e); } catch (i) { d.log(h, `cannot check condition [${a}]${i}`); } } return c;
      }, this.connect = function (a, b) {
        let c,
          e = Q(a, b); if (e) { if (e.source == null && e.sourceEndpoint == null) return d.log('Cannot establish connection - source does not exist'), void 0; if (e.target == null && e.targetEndpoint == null) return d.log('Cannot establish connection - target does not exist'), void 0; sb(e.source), c = R(e), S(c, e); } return c;
      }; let _ = [{ el: 'source', elId: 'sourceId', epDefs: 'sourceEndpointDefinitions' }, { el: 'target', elId: 'targetId', epDefs: 'targetEndpointDefinitions' }],
        ab = function (a, b, c, d) {
          let e,
            f,
            g,
            h = _[c],
            i = a[h.elId],
            j = (a[h.el], a.endpoints[c]),
            k = {
              index: c, originalSourceId: c === 0 ? i : a.sourceId, newSourceId: a.sourceId, originalTargetId: c === 1 ? i : a.targetId, newTargetId: a.targetId, connection: a
            }; if (b.constructor === r.Endpoint)e = b, e.addConnection(a), b = e.element; else if (f = $(b), g = this[h.epDefs][f], f === a[h.elId])e = null; else if (g) for (const l in g) { if (!g[l].enabled) return; e = g[l].endpoint != null && g[l].endpoint._jsPlumb ? g[l].endpoint : this.addEndpoint(b, g[l].def), g[l].uniqueEndpoint && (g[l].endpoint = e), e.addConnection(a); } else e = a.makeEndpoint(c === 0, b, f); return e != null && (j.detachFromConnection(a), a.endpoints[c] = e, a[h.el] = e.element, a[h.elId] = e.elementId, k[c === 0 ? 'newSourceId' : 'newTargetId'] = e.elementId, cb(k), d || a.repaint()), k.element = b, k;
        }.bind(this); this.setSource = function (a, b, c) { const d = ab(a, b, 0, c); this.anchorManager.sourceChanged(d.originalSourceId, d.newSourceId, a, d.el); }, this.setTarget = function (a, b, c) { const d = ab(a, b, 1, c); this.anchorManager.updateOtherEndpoint(d.originalSourceId, d.originalTargetId, d.newTargetId, a); }, this.deleteEndpoint = function (a, b, c) { const d = typeof a === 'string' ? y[a] : a; return d && h.deleteObject({ endpoint: d, dontUpdateHover: b, deleteAttachedObjects: c }), h; }, this.deleteEveryEndpoint = function () { const a = h.setSuspendDrawing(!0); for (const b in x) { const c = x[b]; if (c && c.length) for (let d = 0, e = c.length; e > d; d++)h.deleteEndpoint(c[d], !0); }x = {}, z = {}, y = {}, A = {}, B = {}, h.anchorManager.reset(); const f = h.getDragManager(); return f && f.reset(), a || h.setSuspendDrawing(!1), h; }; var bb = function (a, b, c) {
          let d = h.Defaults.ConnectionType || h.getDefaultConnectionType(),
            e = a.constructor === d,
            f = e ? {
              connection: a, source: a.source, target: a.target, sourceId: a.sourceId, targetId: a.targetId, sourceEndpoint: a.endpoints[0], targetEndpoint: a.endpoints[1]
            } : a; b && h.fire('connectionDetached', f, c), h.fire('internal.connectionDetached', f, c), h.anchorManager.connectionDetached(f);
        },
        cb = h.fireMoveEvent = function (a, b) { h.fire('connectionMoved', a, b); }; this.unregisterEndpoint = function (a) { a._jsPlumb.uuid && (y[a._jsPlumb.uuid] = null), h.anchorManager.deleteEndpoint(a); for (const b in x) { const c = x[b]; if (c) { for (var d = [], e = 0, f = c.length; f > e; e++)c[e] !== a && d.push(c[e]); x[b] = d; }x[b].length < 1 && delete x[b]; } }; let db = 'isDetachAllowed',
        eb = 'beforeDetach',
        fb = 'checkCondition'; this.deleteConnection = function (a, b) { return a != null && (b = b || {}, b.force || d.functionChain(!0, !1, [[a.endpoints[0], db, [a]], [a.endpoints[1], db, [a]], [a, db, [a]], [h, fb, [eb, a]]])) ? (a.setHover(!1), bb(a, !a.pending && b.fireEvent !== !1, b.originalEvent), a.endpoints[0].detachFromConnection(a), a.endpoints[1].detachFromConnection(a), d.removeWithFunction(w, b => a.id === b.id), a.cleanup(), a.destroy(), !0) : !1; }, this.deleteEveryConnection = function (a) {
        a = a || {}; let b = w.length,
          c = 0; return h.batch(() => { for (let d = 0; b > d; d++)c += h.deleteConnection(w[0], a) ? 1 : 0; }), c;
      }, this.deleteConnectionsForElement = function (a, b) {
        b = b || {}, a = h.getElement(a); let c = $(a),
          d = x[c]; if (d && d.length) for (let e = 0, f = d.length; f > e; e++)d[e].deleteEveryConnection(b); return h;
      }, this.deleteObject = function (a) {
        let b = {
            endpoints: {}, connections: {}, endpointCount: 0, connectionCount: 0
          },
          c = a.deleteAttachedObjects !== !1,
          e = function (c) { c != null && b.connections[c.id] == null && (a.dontUpdateHover || c._jsPlumb == null || c.setHover(!1), b.connections[c.id] = c, b.connectionCount++); },
          f = function (d) { if (d != null && b.endpoints[d.id] == null && (a.dontUpdateHover || d._jsPlumb == null || d.setHover(!1), b.endpoints[d.id] = d, b.endpointCount++, c)) for (let f = 0; f < d.connections.length; f++) { const g = d.connections[f]; e(g); } }; a.connection ? e(a.connection) : f(a.endpoint); for (const g in b.connections) { var i = b.connections[g]; if (i._jsPlumb) { d.removeWithFunction(w, a => i.id === a.id), bb(i, a.fireEvent === !1 ? !1 : !i.pending, a.originalEvent); const j = a.deleteAttachedObjects == null ? null : !a.deleteAttachedObjects; i.endpoints[0].detachFromConnection(i, null, j), i.endpoints[1].detachFromConnection(i, null, j), i.cleanup(!0), i.destroy(!0); } } for (const k in b.endpoints) { const l = b.endpoints[k]; l._jsPlumb && (h.unregisterEndpoint(l), l.cleanup(!0), l.destroy(!0)); } return b;
      }, this.draggable = function (a, b) { let c; return k((a) => { c = o(a), c.el && N(c.el, !0, b, c.id, !0); }, a), h; }, this.droppable = function (a, b) { let c; return b = b || {}, b.allowLoopback = !1, k((a) => { c = o(a), c.el && h.initDroppable(c.el, b); }, a), h; }; let gb = function (a, b, c, d) { for (let e = 0, f = a.length; f > e; e++)a[e][b].apply(a[e], c); return d(a); },
        hb = function (a, b, c) { for (var d = [], e = 0, f = a.length; f > e; e++)d.push([a[e][b].apply(a[e], c), a[e]]); return d; },
        ib = function (a, b, c) { return function () { return gb(a, b, arguments, c); }; },
        jb = function (a, b) { return function () { return hb(a, b, arguments); }; },
        kb = function (a, b) { let c = []; if (a) if (typeof a === 'string') { if (a === '*') return a; c.push(a); } else if (b)c = a; else if (a.length) for (let d = 0, e = a.length; e > d; d++)c.push(o(a[d]).id); else c.push(o(a).id); return c; },
        lb = function (a, b, c) { return a === '*' ? !0 : a.length > 0 ? a.indexOf(b) !== -1 : !c; }; this.getConnections = function (a, b) {
        a ? a.constructor === String && (a = { scope: a }) : a = {}; for (var c = a.scope || h.getDefaultScope(), d = kb(c, !0), e = kb(a.source), f = kb(a.target), g = !b && d.length > 1 ? {} : [], i = function (a, c) { if (!b && d.length > 1) { let e = g[a]; e == null && (e = g[a] = []), e.push(c); } else g.push(c); }, j = 0, k = w.length; k > j; j++) {
          let l = w[j],
            m = l.proxies && l.proxies[0] ? l.proxies[0].originalEp.elementId : l.sourceId,
            n = l.proxies && l.proxies[1] ? l.proxies[1].originalEp.elementId : l.targetId; lb(d, l.scope) && lb(e, m) && lb(f, n) && i(l.scope, l);
        } return g;
      }; var mb = function (a, b) { return function (c) { for (let d = 0, e = a.length; e > d; d++)c(a[d]); return b(a); }; },
        nb = function (a) { return function (b) { return a[b]; }; },
        ob = function (a, b) {
          let c,
            d,
            e = { length: a.length, each: mb(a, b), get: nb(a) },
            f = ['setHover', 'removeAllOverlays', 'setLabel', 'addClass', 'addOverlay', 'removeOverlay', 'removeOverlays', 'showOverlay', 'hideOverlay', 'showOverlays', 'hideOverlays', 'setPaintStyle', 'setHoverPaintStyle', 'setSuspendEvents', 'setParameter', 'setParameters', 'setVisible', 'repaint', 'addType', 'toggleType', 'removeType', 'removeClass', 'setType', 'bind', 'unbind'],
            g = ['getLabel', 'getOverlay', 'isHover', 'getParameter', 'getParameters', 'getPaintStyle', 'getHoverPaintStyle', 'isVisible', 'hasType', 'getType', 'isSuspendEvents']; for (c = 0, d = f.length; d > c; c++)e[f[c]] = ib(a, f[c], b); for (c = 0, d = g.length; d > c; c++)e[g[c]] = jb(a, g[c]); return e;
        },
        pb = function (a) {
          const b = ob(a, pb); return r.extend(b, {
            setDetachable: ib(a, 'setDetachable', pb), setReattach: ib(a, 'setReattach', pb), setConnector: ib(a, 'setConnector', pb), delete() { for (let b = 0, c = a.length; c > b; b++)h.deleteConnection(a[b]); }, isDetachable: jb(a, 'isDetachable'), isReattach: jb(a, 'isReattach')
          });
        },
        qb = function (a) {
          const b = ob(a, qb); return r.extend(b, {
            setEnabled: ib(a, 'setEnabled', qb), setAnchor: ib(a, 'setAnchor', qb), isEnabled: jb(a, 'isEnabled'), deleteEveryConnection() { for (let b = 0, c = a.length; c > b; b++)a[b].deleteEveryConnection(); }, delete() { for (let b = 0, c = a.length; c > b; b++)h.deleteEndpoint(a[b]); }
          });
        }; this.select = function (a) { return a = a || {}, a.scope = a.scope || '*', pb(a.connections || h.getConnections(a, !0)); }, this.selectEndpoints = function (a) {
        a = a || {}, a.scope = a.scope || '*'; let b = !a.element && !a.source && !a.target,
          c = b ? '*' : kb(a.element),
          d = b ? '*' : kb(a.source),
          e = b ? '*' : kb(a.target),
          f = kb(a.scope, !0),
          g = []; for (const h in x) {
          let i = lb(c, h, !0),
            j = lb(d, h, !0),
            k = d !== '*',
            l = lb(e, h, !0),
            m = e !== '*'; if (i || j || l) {
            for (let n = 0, o = x[h].length; o > n; n++) {
              const p = x[h][n]; if (lb(f, p.scope, !0)) {
                let q = k && d.length > 0 && !p.isSource,
                  r = m && e.length > 0 && !p.isTarget; if (q || r) continue; g.push(p);
              }
            }
          }
        } return qb(g);
      }, this.getAllConnections = function () { return w; }, this.getDefaultScope = function () { return H; }, this.getEndpoint = M, this.getEndpoints = function (a) { return x[o(a).id] || []; }, this.getDefaultEndpointType = function () { return r.Endpoint; }, this.getDefaultConnectionType = function () { return r.Connection; }, this.getId = $, this.appendElement = K; let rb = !1; this.isHoverSuspended = function () { return rb; }, this.setHoverSuspended = function (a) { rb = a; }, this.hide = function (a, b) { return W(a, 'none', b), h; }, this.idstamp = J, this.connectorsInitialized = !1, this.registerConnectorType = function (a, b) { c.push([a, b]); }; var sb = function (a) { if (!s && a) { const b = h.getElement(a); b.offsetParent && h.setContainer(b.offsetParent); } },
        tb = function () { h.Defaults.Container && h.setContainer(h.Defaults.Container); },
        ub = h.manage = function (a, b, c) { return z[a] || (z[a] = { el: b, endpoints: [], connections: [] }, z[a].info = vb({ elId: a, timestamp: G }), c || h.fire('manageElement', { id: a, info: z[a].info, el: b })), z[a]; },
        vb = this.updateOffset = function (a) {
          let b,
            c = a.timestamp,
            d = a.recalc,
            e = a.offset,
            f = a.elId; return F && !c && (c = G), !d && c && c === B[f] ? { o: a.offset || A[f], s: E[f] } : (d || !e && A[f] == null ? (b = z[f] ? z[f].el : null, b != null && (E[f] = h.getSize(b), A[f] = h.getOffset(b), B[f] = c)) : (A[f] = e || A[f], E[f] == null && (b = z[f].el, b != null && (E[f] = h.getSize(b))), B[f] = c), A[f] && !A[f].right && (A[f].right = A[f].left + E[f][0], A[f].bottom = A[f].top + E[f][1], A[f].width = E[f][0], A[f].height = E[f][1], A[f].centerx = A[f].left + A[f].width / 2, A[f].centery = A[f].top + A[f].height / 2), { o: A[f], s: E[f] });
        }; this.init = function () {
        a = b.jsPlumb.getRenderModes(); const e = function (a, c, e) {
          b.jsPlumb.Connectors[a][c] = function () { e.apply(this, arguments), b.jsPlumb.ConnectorRenderers[a].apply(this, arguments); }, d.extend(b.jsPlumb.Connectors[a][c], [e, b.jsPlumb.ConnectorRenderers[a]]);
        }; if (!b.jsPlumb.connectorsInitialized) { for (let f = 0; f < c.length; f++) for (let g = 0; g < a.length; g++)e(a[g], c[f][1], c[f][0]); b.jsPlumb.connectorsInitialized = !0; }v || (tb(), h.anchorManager = new b.jsPlumb.AnchorManager({ jsPlumbInstance: h }), v = !0, h.fire('ready', h));
      }, this.log = u, this.jsPlumbUIComponent = m, this.makeAnchor = function () {
        let a,
          c = function (a, c) { if (b.jsPlumb.Anchors[a]) return new b.jsPlumb.Anchors[a](c); if (!h.Defaults.DoNotThrowErrors) throw { msg: `jsPlumb: unknown anchor type '${a}'` }; }; if (arguments.length === 0) return null; let e = arguments[0],
          f = arguments[1],
          g = (arguments[2], null); if (e.compute && e.getOrientation) return e; if (typeof e === 'string')g = c(arguments[0], { elementId: f, jsPlumbInstance: h }); else if (d.isArray(e)) {
          if (d.isArray(e[0]) || d.isString(e[0])) {
            e.length === 2 && d.isObject(e[1]) ? d.isString(e[0]) ? (a = b.jsPlumb.extend({ elementId: f, jsPlumbInstance: h }, e[1]), g = c(e[0], a)) : (a = b.jsPlumb.extend({ elementId: f, jsPlumbInstance: h, anchors: e[0] }, e[1]), g = new b.jsPlumb.DynamicAnchor(a)) : g = new r.DynamicAnchor({
              anchors: e, selector: null, elementId: f, jsPlumbInstance: h
            });
          } else {
            const i = {
              x: e[0], y: e[1], orientation: e.length >= 4 ? [e[2], e[3]] : [0, 0], offsets: e.length >= 6 ? [e[4], e[5]] : [0, 0], elementId: f, jsPlumbInstance: h, cssClass: e.length === 7 ? e[6] : null
            }; g = new b.jsPlumb.Anchor(i), g.clone = function () { return new b.jsPlumb.Anchor(i); };
          }
        } return g.id || (g.id = `anchor_${J()}`), g;
      }, this.makeAnchors = function (a, c, e) { for (var f = [], g = 0, i = a.length; i > g; g++) typeof a[g] === 'string' ? f.push(b.jsPlumb.Anchors[a[g]]({ elementId: c, jsPlumbInstance: e })) : d.isArray(a[g]) && f.push(h.makeAnchor(a[g], c, e)); return f; }, this.makeDynamicAnchor = function (a, c) {
        return new b.jsPlumb.DynamicAnchor({
          anchors: a, selector: c, elementId: null, jsPlumbInstance: h
        });
      }, this.targetEndpointDefinitions = {}, this.sourceEndpointDefinitions = {}; let wb = function (a, b, c, d, e) { for (var f = a.target || a.srcElement, g = !1, h = d.getSelector(b, c), i = 0; i < h.length; i++) if (h[i] === f) { g = !0; break; } return e ? !g : g; },
        xb = function (a, c, e, f, g) {
          let i = new m(c),
            j = c._jsPlumb.EndpointDropHandler({
              jsPlumb: h,
              enabled() { return a.def.enabled; },
              isFull() { const b = h.select({ target: a.id }).length; return a.def.maxConnections > 0 && b >= a.def.maxConnections; },
              element: a.el,
              elementId: a.id,
              isSource: f,
              isTarget: g,
              addClass(b) { h.addClass(a.el, b); },
              removeClass(b) { h.removeClass(a.el, b); },
              onDrop(a) { const b = a.endpoints[0]; b.anchor.locked = !1; },
              isDropAllowed() { return i.isDropAllowed(...arguments); },
              isRedrop(b) { return b.suspendedElement != null && b.suspendedEndpoint != null && b.suspendedEndpoint.element === a.el; },
              getEndpoint(d) {
                let e = a.def.endpoint; if (e == null || e._jsPlumb == null) {
                  let f = h.deriveEndpointAndAnchorSpec(d.getType().join(' '), !0),
                    g = f.endpoints ? b.jsPlumb.extend(c, { endpoint: a.def.def.endpoint || f.endpoints[1] }) : c; f.anchors && (g = b.jsPlumb.extend(g, { anchor: a.def.def.anchor || f.anchors[1] })), e = h.addEndpoint(a.el, g), e._mtNew = !0;
                } if (c.uniqueEndpoint && (a.def.endpoint = e), e.setDeleteOnEmpty(!0), d.isDetachable() && e.initDraggable(), e.anchor.positionFinder != null) {
                  let i = h.getUIPosition(arguments, h.getZoom()),
                    j = h.getOffset(a.el),
                    k = h.getSize(a.el),
                    l = i == null ? [0, 0] : e.anchor.positionFinder(i, j, k, e.anchor.constructorParams); e.anchor.x = l[0], e.anchor.y = l[1];
                } return e;
              },
              maybeCleanup(a) { a._mtNew && a.connections.length === 0 ? h.deleteObject({ endpoint: a }) : delete a._mtNew; }
            }),
            k = b.jsPlumb.dragEvents.drop; return e.scope = e.scope || c.scope || h.Defaults.Scope, e[k] = d.wrap(e[k], j, !0), g && (e[b.jsPlumb.dragEvents.over] = function () { return !0; }), c.allowLoopback === !1 && (e.canDrop = function (b) { const c = b.getDragElement()._jsPlumbRelatedElement; return c !== a.el; }), h.initDroppable(a.el, e, 'internal'), j;
        }; this.makeTarget = function (a, c, d) {
        const e = b.jsPlumb.extend({ _jsPlumb: this }, d); b.jsPlumb.extend(e, c); for (var f = e.maxConnections || -1, g = function (a) {
            let c = o(a),
              d = c.id,
              g = b.jsPlumb.extend({}, e.dropOptions || {}),
              i = e.connectionType || 'default'; this.targetEndpointDefinitions[d] = this.targetEndpointDefinitions[d] || {}, sb(d), c.el._isJsPlumbGroup && g.rank == null && (g.rank = -1); const j = {
              def: b.jsPlumb.extend({}, e), uniqueEndpoint: e.uniqueEndpoint, maxConnections: f, enabled: !0
            }; e.createEndpoint && (j.uniqueEndpoint = !0, j.endpoint = h.addEndpoint(a, j.def), j.endpoint.setDeleteOnEmpty(!1)), c.def = j, this.targetEndpointDefinitions[d][i] = j, xb(c, e, g, e.isSource === !0, !0), c.el._katavorioDrop[c.el._katavorioDrop.length - 1].targetDef = j;
          }.bind(this), i = a.length && a.constructor !== String ? a : [a], j = 0, k = i.length; k > j; j++)g(i[j]); return this;
      }, this.unmakeTarget = function (a, b) { const c = o(a); return h.destroyDroppable(c.el, 'internal'), b || delete this.targetEndpointDefinitions[c.id], this; }, this.makeSource = function (a, c, e) {
        const f = b.jsPlumb.extend({ _jsPlumb: this }, e); b.jsPlumb.extend(f, c); let g = f.connectionType || 'default',
          i = h.deriveEndpointAndAnchorSpec(g); f.endpoint = f.endpoint || i.endpoints[0], f.anchor = f.anchor || i.anchors[0]; for (var j = f.maxConnections || -1, k = f.onMaxConnections, l = function (c) {
            let e = c.id,
              i = this.getElement(c.el); this.sourceEndpointDefinitions[e] = this.sourceEndpointDefinitions[e] || {}, sb(e); const l = {
              def: b.jsPlumb.extend({}, f), uniqueEndpoint: f.uniqueEndpoint, maxConnections: j, enabled: !0
            }; f.createEndpoint && (l.uniqueEndpoint = !0, l.endpoint = h.addEndpoint(a, l.def), l.endpoint.setDeleteOnEmpty(!1)), this.sourceEndpointDefinitions[e][g] = l, c.def = l; let m = b.jsPlumb.dragEvents.stop,
              o = b.jsPlumb.dragEvents.drag,
              p = b.jsPlumb.extend({}, f.dragOptions || {}),
              q = p.drag,
              r = p.stop,
              s = null,
              t = !1; p.scope = p.scope || f.scope, p[o] = d.wrap(p[o], function () { q && q.apply(this, arguments), t = !1; }), p[m] = d.wrap(p[m], function () {
              if (r && r.apply(this, arguments), this.currentlyDragging = !1, s._jsPlumb != null) {
                let a = f.anchor || this.Defaults.Anchor,
                  b = s.anchor,
                  c = s.connections[0],
                  d = this.makeAnchor(a, e, this),
                  g = s.element; if (d.positionFinder != null) {
                  let i = h.getOffset(g),
                    j = this.getSize(g),
                    k = { left: i.left + b.x * j[0], top: i.top + b.y * j[1] },
                    l = d.positionFinder(k, i, j, d.constructorParams); d.x = l[0], d.y = l[1];
                }s.setAnchor(d, !0), s.repaint(), this.repaint(s.elementId), c != null && this.repaint(c.targetId);
              }
            }.bind(this)); const u = function (a) {
              if (a.which !== 3 && a.button !== 2) {
                const l = this.sourceEndpointDefinitions[e][g]; if (l.enabled) {
                  if (e = this.getId(this.getElement(c.el)), f.filter) { const m = d.isString(f.filter) ? wb(a, c.el, f.filter, this, f.filterExclude) : f.filter(a, c.el); if (m === !1) return; } const o = this.select({ source: e }).length; if (l.maxConnections >= 0 && o >= l.maxConnections) return k && k({ element: c.el, maxConnections: j }, a), !1; let q = b.jsPlumb.getPositionOnElement(a, i, n),
                    r = {}; b.jsPlumb.extend(r, f), r.isTemporarySource = !0, r.anchor = [q[0], q[1], 0, 0], r.dragOptions = p, l.def.scope && (r.scope = l.def.scope), s = this.addEndpoint(e, r), t = !0, s.setDeleteOnEmpty(!0), l.uniqueEndpoint && (l.endpoint ? s.finalEndpoint = l.endpoint : (l.endpoint = s, s.setDeleteOnEmpty(!1))); var u = function () { h.off(s.canvas, 'mouseup', u), h.off(c.el, 'mouseup', u), t && (t = !1, h.deleteEndpoint(s)); }; h.on(s.canvas, 'mouseup', u), h.on(c.el, 'mouseup', u); const v = {}; if (l.def.extract) for (const w in l.def.extract) { const x = (a.srcElement || a.target).getAttribute(w); x && (v[l.def.extract[w]] = x); }h.trigger(s.canvas, 'mousedown', a, v), d.consume(a);
                }
              }
            }.bind(this); this.on(c.el, 'mousedown', u), l.trigger = u, f.filter && (d.isString(f.filter) || d.isFunction(f.filter)) && h.setDragFilter(c.el, f.filter); const v = b.jsPlumb.extend({}, f.dropOptions || {}); xb(c, f, v, !0, f.isTarget === !0);
          }.bind(this), m = a.length && a.constructor !== String ? a : [a], p = 0, q = m.length; q > p; p++)l(o(m[p])); return this;
      }, this.unmakeSource = function (a, b, c) { const d = o(a); h.destroyDroppable(d.el, 'internal'); const e = this.sourceEndpointDefinitions[d.id]; if (e) for (const f in e) if (b == null || b === f) { const g = e[f].trigger; g && h.off(d.el, 'mousedown', g), c || delete this.sourceEndpointDefinitions[d.id][f]; } return this; }, this.unmakeEverySource = function () { for (const a in this.sourceEndpointDefinitions)h.unmakeSource(a, null, !0); return this.sourceEndpointDefinitions = {}, this; }; let yb = function (a, b, c) { b = d.isArray(b) ? b : [b]; const e = $(a); c = c || 'default'; for (let f = 0; f < b.length; f++) { const g = this[b[f]][e]; if (g && g[c]) return g[c].def.scope || this.Defaults.Scope; } }.bind(this),
        zb = function (a, b, c, e) { c = d.isArray(c) ? c : [c]; const f = $(a); e = e || 'default'; for (let g = 0; g < c.length; g++) { const h = this[c[g]][f]; h && h[e] && (h[e].def.scope = b); } }.bind(this); this.getScope = function (a) { return yb(a, ['sourceEndpointDefinitions', 'targetEndpointDefinitions']); }, this.getSourceScope = function (a) { return yb(a, 'sourceEndpointDefinitions'); }, this.getTargetScope = function (a) { return yb(a, 'targetEndpointDefinitions'); }, this.setScope = function (a, b, c) { this.setSourceScope(a, b, c), this.setTargetScope(a, b, c); }, this.setSourceScope = function (a, b, c) { zb(a, b, 'sourceEndpointDefinitions', c), this.setDragScope(a, b); }, this.setTargetScope = function (a, b, c) { zb(a, b, 'targetEndpointDefinitions', c), this.setDropScope(a, b); }, this.unmakeEveryTarget = function () { for (const a in this.targetEndpointDefinitions)h.unmakeTarget(a, !0); return this.targetEndpointDefinitions = {}, this; }; let Ab = function (a, b, c, e, f) {
          let g,
            i,
            j,
            k = a === 'source' ? this.sourceEndpointDefinitions : this.targetEndpointDefinitions; if (f = f || 'default', b.length && !d.isString(b)) { g = []; for (let l = 0, m = b.length; m > l; l++)i = o(b[l]), k[i.id] && k[i.id][f] && (g[l] = k[i.id][f].enabled, j = e ? !g[l] : c, k[i.id][f].enabled = j, h[j ? 'removeClass' : 'addClass'](i.el, `jtk-${a}-disabled`)); } else { i = o(b); const n = i.id; k[n] && k[n][f] && (g = k[n][f].enabled, j = e ? !g : c, k[n][f].enabled = j, h[j ? 'removeClass' : 'addClass'](i.el, `jtk-${a}-disabled`)); } return g;
        }.bind(this),
        Bb = function (a, b) { return d.isString(a) || !a.length ? b.apply(this, [a]) : a.length ? b.apply(this, [a[0]]) : void 0; }.bind(this); this.toggleSourceEnabled = function (a, b) { return Ab('source', a, null, !0, b), this.isSourceEnabled(a, b); }, this.setSourceEnabled = function (a, b, c) { return Ab('source', a, b, null, c); }, this.isSource = function (a, b) { return b = b || 'default', Bb(a, (a) => { const c = this.sourceEndpointDefinitions[o(a).id]; return c != null && c[b] != null; }); }, this.isSourceEnabled = function (a, b) { return b = b || 'default', Bb(a, (a) => { const c = this.sourceEndpointDefinitions[o(a).id]; return c && c[b] && c[b].enabled === !0; }); }, this.toggleTargetEnabled = function (a, b) { return Ab('target', a, null, !0, b), this.isTargetEnabled(a, b); }, this.isTarget = function (a, b) { return b = b || 'default', Bb(a, (a) => { const c = this.targetEndpointDefinitions[o(a).id]; return c != null && c[b] != null; }); }, this.isTargetEnabled = function (a, b) { return b = b || 'default', Bb(a, (a) => { const c = this.targetEndpointDefinitions[o(a).id]; return c && c[b] && c[b].enabled === !0; }); }, this.setTargetEnabled = function (a, b, c) { return Ab('target', a, b, null, c); }, this.ready = function (a) { h.bind('ready', a); }; const Cb = function (a, b) { if (typeof a === 'object' && a.length) for (let c = 0, d = a.length; d > c; c++)b(a[c]); else b(a); return h; }; this.repaint = function (a, b, c) { return Cb(a, (a) => { L(a, b, c); }); }, this.revalidate = function (a, b, c) { return Cb(a, (a) => { const d = c ? a : h.getId(a); h.updateOffset({ elId: d, recalc: !0, timestamp: b }); const e = h.getDragManager(); e && e.updateOffsets(d), h.repaint(a); }); }, this.repaintEverything = function () {
        let a,
          b = e(); for (a in x)h.updateOffset({ elId: a, recalc: !0, timestamp: b }); for (a in x)L(a, null, b); return this;
      }, this.removeAllEndpoints = function (a, b, c) {
        c = c || []; var d = function (a) {
          let e,
            f,
            g = o(a),
            i = x[g.id]; if (i) for (c.push(g), e = 0, f = i.length; f > e; e++)h.deleteEndpoint(i[e], !1); if (delete x[g.id], b && g.el && g.el.nodeType !== 3 && g.el.nodeType !== 8) for (e = 0, f = g.el.childNodes.length; f > e; e++)d(g.el.childNodes[e]);
        }; return d(a), this;
      }; const Db = function (a, b) { h.removeAllEndpoints(a.id, !0, b); for (var c = h.getDragManager(), d = function (a) { c && c.elementRemoved(a.id), h.anchorManager.clearFor(a.id), h.anchorManager.removeFloatingConnection(a.id), h.isSource(a.el) && h.unmakeSource(a.el), h.isTarget(a.el) && h.unmakeTarget(a.el), h.destroyDraggable(a.el), h.destroyDroppable(a.el), delete h.floatingConnections[a.id], delete z[a.id], delete A[a.id], a.el && (h.removeElement(a.el), a.el._jsPlumb = null); }, e = 1; e < b.length; e++)d(b[e]); d(a); }; this.remove = function (a, b) {
        let c = o(a),
          d = []; return c.text ? c.el.parentNode.removeChild(c.el) : c.id && h.batch(() => { Db(c, d); }, b === !1), h;
      }, this.empty = function (a, b) {
        var c = [],
          d = function (a, b) { const e = o(a); if (e.text)e.el.parentNode.removeChild(e.el); else if (e.el) { for (;e.el.childNodes.length > 0;)d(e.el.childNodes[0]); b || Db(e, c); } }; return h.batch(() => { d(a, !0); }, b === !1), h;
      }, this.reset = function () { h.silently(() => { rb = !1, h.removeAllGroups(), h.removeGroupManager(), h.deleteEveryEndpoint(), h.unbind(), this.targetEndpointDefinitions = {}, this.sourceEndpointDefinitions = {}, w.length = 0, this.doReset && this.doReset(); }); }; const Eb = function (a) { a.canvas && a.canvas.parentNode && a.canvas.parentNode.removeChild(a.canvas), a.cleanup(), a.destroy(); }; this.clear = function () { h.select().each(Eb), h.selectEndpoints().each(Eb), x = {}, y = {}; }, this.setDefaultScope = function (a) { return H = a, h; }, this.setDraggable = V, this.deriveEndpointAndAnchorSpec = function (a, b) { for (var c = ((b ? '' : 'default ') + a).split(/[\s]/), d = null, e = null, f = null, g = null, i = 0; i < c.length; i++) { const j = h.getType(c[i], 'connection'); j && (j.endpoints && (d = j.endpoints), j.endpoint && (e = j.endpoint), j.anchors && (g = j.anchors), j.anchor && (f = j.anchor)); } return { endpoints: d || [e, e], anchors: g || [f, f] }; }, this.setId = function (a, b, c) {
        let e; d.isString(a) ? e = a : (a = this.getElement(a), e = this.getId(a)); let f = this.getConnections({ source: e, scope: '*' }, !0),
          g = this.getConnections({ target: e, scope: '*' }, !0); b = `${b}`, c ? a = this.getElement(b) : (a = this.getElement(e), this.setAttribute(a, 'id', b)), x[b] = x[e] || []; for (let h = 0, i = x[b].length; i > h; h++)x[b][h].setElementId(b), x[b][h].setReferenceElement(a); delete x[e], this.sourceEndpointDefinitions[b] = this.sourceEndpointDefinitions[e], delete this.sourceEndpointDefinitions[e], this.targetEndpointDefinitions[b] = this.targetEndpointDefinitions[e], delete this.targetEndpointDefinitions[e], this.anchorManager.changeId(e, b); const j = this.getDragManager(); j && j.changeId(e, b), z[b] = z[e], delete z[e]; const k = function (c, d, e) { for (let f = 0, g = c.length; g > f; f++)c[f].endpoints[d].setElementId(b), c[f].endpoints[d].setReferenceElement(a), c[f][`${e}Id`] = b, c[f][e] = a; }; k(f, 0, 'source'), k(g, 1, 'target'), this.repaint(b);
      }, this.setDebugLog = function (a) { u = a; }, this.setSuspendDrawing = function (a, b) { const c = F; return F = a, G = a ? (new Date()).getTime() : null, b && this.repaintEverything(), c; }, this.isSuspendDrawing = function () { return F; }, this.getSuspendedAt = function () { return G; }, this.batch = function (a, b) { const c = this.isSuspendDrawing(); c || this.setSuspendDrawing(!0); try { a(); } catch (e) { d.log('Function run while suspended failed', e); }c || this.setSuspendDrawing(!1, !b); }, this.doWhileSuspended = this.batch, this.getCachedData = Z, this.timestamp = e, this.show = function (a, b) { return W(a, 'block', b), h; }, this.toggleVisible = Y, this.toggleDraggable = X, this.addListener = this.bind;
    }; d.extend(b.jsPlumbInstance, d.EventGenerator, {
    setAttribute(a, b, c) { this.setAttribute(a, b, c); },
    getAttribute(a, c) { return this.getAttribute(b.jsPlumb.getElement(a), c); },
    convertToFullOverlaySpec(a) { return d.isString(a) && (a = [a, {}]), a[1].id = a[1].id || d.uuid(), a; },
    registerConnectionType(a, c) { if (this._connectionTypes[a] = b.jsPlumb.extend({}, c), c.overlays) { for (var d = {}, e = 0; e < c.overlays.length; e++) { const f = this.convertToFullOverlaySpec(c.overlays[e]); d[f[1].id] = f; } this._connectionTypes[a].overlays = d; } },
    registerConnectionTypes(a) { for (const b in a) this.registerConnectionType(b, a[b]); },
    registerEndpointType(a, c) { if (this._endpointTypes[a] = b.jsPlumb.extend({}, c), c.overlays) { for (var d = {}, e = 0; e < c.overlays.length; e++) { const f = this.convertToFullOverlaySpec(c.overlays[e]); d[f[1].id] = f; } this._endpointTypes[a].overlays = d; } },
    registerEndpointTypes(a) { for (const b in a) this.registerEndpointType(b, a[b]); },
    getType(a, b) { return b === 'connection' ? this._connectionTypes[a] : this._endpointTypes[a]; },
    setIdChanged(a, b) { this.setId(a, b, !0); },
    setParent(a, b) {
      let c = this.getElement(a),
        d = this.getId(c),
        e = this.getElement(b),
        f = this.getId(e),
        g = this.getDragManager(); c.parentNode.removeChild(c), e.appendChild(c), g && g.setParent(c, d, e, f);
    },
    extend(a, b, c) { let d; if (c) for (d = 0; d < c.length; d++)a[c[d]] = b[c[d]]; else for (d in b)a[d] = b[d]; return a; },
    floatingConnections: {},
    getFloatingAnchorIndex(a) { return a.endpoints[0].isFloating() ? 0 : a.endpoints[1].isFloating() ? 1 : -1; }
  }), q.prototype.Defaults = {
    Anchor: 'Bottom', Anchors: [null, null], ConnectionsDetachable: !0, ConnectionOverlays: [], Connector: 'Bezier', Container: null, DoNotThrowErrors: !1, DragOptions: {}, DropOptions: {}, Endpoint: 'Dot', EndpointOverlays: [], Endpoints: [null, null], EndpointStyle: { fill: '#456' }, EndpointStyles: [null, null], EndpointHoverStyle: null, EndpointHoverStyles: [null, null], HoverPaintStyle: null, LabelStyle: { color: 'black' }, LogEnabled: !1, Overlays: [], MaxConnections: 1, PaintStyle: { 'stroke-width': 4, stroke: '#456' }, ReattachConnections: !1, RenderMode: 'svg', Scope: 'jsPlumb_DefaultScope'
  }; var r = new q(); b.jsPlumb = r, r.getInstance = function (a, b) { const c = new q(a); if (b) for (const d in b)c[d] = b[d]; return c.init(), c; }, r.each = function (a, b) { if (a != null) if (typeof a === 'string')b(r.getElement(a)); else if (a.length != null) for (let c = 0; c < a.length; c++)b(r.getElement(a[c])); else b(a); }, typeof exports !== 'undefined' && (exports.jsPlumb = r);
}.call(typeof window !== 'undefined' ? window : this), function () {
  var a = this,
    b = a.jsPlumbUtil,
    c = function (a, b) {
      if (b == null) return [0, 0]; let c = h(b),
        d = g(c, 0); return [d[`${a}X`], d[`${a}Y`]];
    },
    d = c.bind(this, 'page'),
    e = c.bind(this, 'screen'),
    f = c.bind(this, 'client'),
    g = function (a, b) { return a.item ? a.item(b) : a[b]; },
    h = function (a) { return a.touches && a.touches.length > 0 ? a.touches : a.changedTouches && a.changedTouches.length > 0 ? a.changedTouches : a.targetTouches && a.targetTouches.length > 0 ? a.targetTouches : [a]; },
    i = function (a) {
      let b = {},
        c = [],
        d = {},
        e = {},
        f = {}; this.register = function (g) {
        let h = a.getId(g),
          i = a.getOffset(g); b[h] || (b[h] = g, c.push(g), d[h] = {}); var j = function (b) {
          if (b) {
            for (let c = 0; c < b.childNodes.length; c++) {
              if (b.childNodes[c].nodeType !== 3 && b.childNodes[c].nodeType !== 8) {
                let g = jsPlumb.getElement(b.childNodes[c]),
                  k = a.getId(b.childNodes[c], null, !0); if (k && e[k] && e[k] > 0) { const l = a.getOffset(g); d[h][k] = { id: k, offset: { left: l.left - i.left, top: l.top - i.top } }, f[k] = h; }j(b.childNodes[c]);
              }
            }
          }
        }; j(g);
      }, this.updateOffsets = function (b, c) {
        if (b != null) {
          c = c || {}; let e = jsPlumb.getElement(b),
            g = a.getId(e),
            h = d[g],
            i = a.getOffset(e); if (h) {
            for (const j in h) {
              if (h.hasOwnProperty(j)) {
                let k = jsPlumb.getElement(j),
                  l = c[j] || a.getOffset(k); if (k.offsetParent == null && d[g][j] != null) continue; d[g][j] = { id: j, offset: { left: l.left - i.left, top: l.top - i.top } }, f[j] = g;
              }
            }
          }
        }
      }, this.endpointAdded = function (c, g) {
        g = g || a.getId(c); let h = document.body,
          i = c.parentNode; for (e[g] = e[g] ? e[g] + 1 : 1; i != null && i !== h;) { const j = a.getId(i, null, !0); if (j && b[j]) { const k = a.getOffset(i); if (d[j][g] == null) { const l = a.getOffset(c); d[j][g] = { id: g, offset: { left: l.left - k.left, top: l.top - k.top } }, f[g] = j; } break; }i = i.parentNode; }
      }, this.endpointDeleted = function (a) { if (e[a.elementId] && (e[a.elementId]--, e[a.elementId] <= 0)) for (const b in d)d.hasOwnProperty(b) && d[b] && (delete d[b][a.elementId], delete f[a.elementId]); }, this.changeId = function (a, b) { d[b] = d[a], d[a] = {}, f[b] = f[a], f[a] = null; }, this.getElementsForDraggable = function (a) { return d[a]; }, this.elementRemoved = function (a) { const b = f[a]; b && (delete d[b][a], delete f[a]); }, this.reset = function () { b = {}, c = [], d = {}, e = {}; }, this.dragEnded = function (b) {
        if (b.offsetParent != null) {
          let c = a.getId(b),
            d = f[c]; d && this.updateOffsets(d);
        }
      }, this.setParent = function (b, c, e, g, h) {
        const i = f[c]; d[g] || (d[g] = {}); let j = a.getOffset(e),
          k = h || a.getOffset(b); i && d[i] && delete d[i][c], d[g][c] = { id: c, offset: { left: k.left - j.left, top: k.top - j.top } }, f[c] = g;
      }, this.clearParent = function (a, b) { const c = f[b]; c && (delete d[c][b], delete f[b]); }, this.revalidateParent = function (b, c, d) { const e = f[c]; if (e) { const g = {}; g[c] = d, this.updateOffsets(e, g), a.revalidate(e); } }, this.getDragAncestor = function (b) {
        let c = jsPlumb.getElement(b),
          d = a.getId(c),
          e = f[d]; return e ? jsPlumb.getElement(e) : null;
      };
    },
    j = function (a) { return a == null ? null : a.replace(/^\s\s*/, '').replace(/\s\s*$/, ''); },
    k = function (a, b, c) { b = j(b), typeof a.className.baseVal !== 'undefined' ? a.className.baseVal = b : a.className = b; try { for (var d = a.classList; d.length > 0;)d.remove(d.item(0)); for (let e = 0; e < c.length; e++)c[e] && d.add(c[e]); } catch (f) { console.log('JSPLUMB: cannot set class list', f); } },
    l = function (a) { return typeof a.className.baseVal === 'undefined' ? a.className : a.className.baseVal; },
    m = function (a, c, d) {
      c = c == null ? [] : b.isArray(c) ? c : c.split(/\s+/), d = d == null ? [] : b.isArray(d) ? d : d.split(/\s+/); let e = l(a),
        f = e.split(/\s+/),
        g = function (a, b) { for (let c = 0; c < b.length; c++) if (a)f.indexOf(b[c]) === -1 && f.push(b[c]); else { const d = f.indexOf(b[c]); d !== -1 && f.splice(d, 1); } }; g(!0, c), g(!1, d), k(a, f.join(' '), f);
    }; a.jsPlumb.extend(a.jsPlumbInstance.prototype, {
    headless: !1,
    pageLocation: d,
    screenLocation: e,
    clientLocation: f,
    getDragManager() { return this.dragManager == null && (this.dragManager = new i(this)), this.dragManager; },
    recalculateOffsets(a) { this.getDragManager().updateOffsets(a); },
    createElement(a, b, c, d) { return this.createElementNS(null, a, b, c, d); },
    createElementNS(a, b, c, d, e) {
      let f,
        g = a == null ? document.createElement(b) : document.createElementNS(a, b); c = c || {}; for (f in c)g.style[f] = c[f]; d && (g.className = d), e = e || {}; for (f in e)g.setAttribute(f, `${e[f]}`); return g;
    },
    getAttribute(a, b) { return a.getAttribute != null ? a.getAttribute(b) : null; },
    setAttribute(a, b, c) { a.setAttribute != null && a.setAttribute(b, c); },
    setAttributes(a, b) { for (const c in b)b.hasOwnProperty(c) && a.setAttribute(c, b[c]); },
    appendToRoot(a) { document.body.appendChild(a); },
    getRenderModes() { return ['svg']; },
    getClass: l,
    addClass(a, b) { jsPlumb.each(a, (a) => { m(a, b); }); },
    hasClass(a, b) { return a = jsPlumb.getElement(a), a.classList ? a.classList.contains(b) : l(a).indexOf(b) !== -1; },
    removeClass(a, b) { jsPlumb.each(a, (a) => { m(a, null, b); }); },
    updateClasses(a, b, c) { jsPlumb.each(a, (a) => { m(a, b, c); }); },
    setClass(a, b) { b != null && jsPlumb.each(a, (a) => { k(a, b, b.split(/\s+/)); }); },
    setPosition(a, b) { a.style.left = `${b.left}px`, a.style.top = `${b.top}px`; },
    getPosition(a) { const b = function (b) { const c = a.style[b]; return c ? c.substring(0, c.length - 2) : 0; }; return { left: b('left'), top: b('top') }; },
    getStyle(a, b) { return typeof window.getComputedStyle !== 'undefined' ? getComputedStyle(a, null).getPropertyValue(b) : a.currentStyle[b]; },
    getSelector(a, b) { let c = null; return c = arguments.length === 1 ? a.nodeType != null ? a : document.querySelectorAll(a) : a.querySelectorAll(b); },
    getOffset(a, b, c) {
      a = jsPlumb.getElement(a), c = c || this.getContainer(); for (var d = { left: a.offsetLeft, top: a.offsetTop }, e = b || c != null && a !== c && a.offsetParent !== c ? a.offsetParent : null, f = function (a) { a != null && a !== document.body && (a.scrollTop > 0 || a.scrollLeft > 0) && (d.left -= a.scrollLeft, d.top -= a.scrollTop); }; e != null;)d.left += e.offsetLeft, d.top += e.offsetTop, f(e), e = b ? e.offsetParent : e.offsetParent === c ? null : e.offsetParent; if (c != null && !b && (c.scrollTop > 0 || c.scrollLeft > 0)) {
        let g = a.offsetParent != null ? this.getStyle(a.offsetParent, 'position') : 'static',
          h = this.getStyle(a, 'position'); h !== 'absolute' && h !== 'fixed' && g !== 'absolute' && g !== 'fixed' && (d.left -= c.scrollLeft, d.top -= c.scrollTop);
      } return d;
    },
    getPositionOnElement(a, b, c) {
      let d = typeof b.getBoundingClientRect !== 'undefined' ? b.getBoundingClientRect() : {
          left: 0, top: 0, width: 0, height: 0
        },
        e = document.body,
        f = document.documentElement,
        g = window.pageYOffset || f.scrollTop || e.scrollTop,
        h = window.pageXOffset || f.scrollLeft || e.scrollLeft,
        i = f.clientTop || e.clientTop || 0,
        j = f.clientLeft || e.clientLeft || 0,
        k = 0,
        l = 0,
        m = d.top + g - i + k * c,
        n = d.left + h - j + l * c,
        o = jsPlumb.pageLocation(a),
        p = d.width || b.offsetWidth * c,
        q = d.height || b.offsetHeight * c,
        r = (o[0] - n) / p,
        s = (o[1] - m) / q; return [r, s];
    },
    getAbsolutePosition(a) { const b = function (b) { const c = a.style[b]; return c ? parseFloat(c.substring(0, c.length - 2)) : void 0; }; return [b('left'), b('top')]; },
    setAbsolutePosition(a, b, c, d) { c ? this.animate(a, { left: `+=${b[0] - c[0]}`, top: `+=${b[1] - c[1]}` }, d) : (a.style.left = `${b[0]}px`, a.style.top = `${b[1]}px`); },
    getSize(a) { return [a.offsetWidth, a.offsetHeight]; },
    getWidth(a) { return a.offsetWidth; },
    getHeight(a) { return a.offsetHeight; },
    getRenderMode() { return 'svg'; }
  });
}.call(typeof window !== 'undefined' ? window : this), function () {
  let a = this,
    b = a.jsPlumb,
    c = a.jsPlumbUtil,
    d = '__label',
    e = function (a, c) {
      let e = {
          cssClass: c.cssClass, labelStyle: a.labelStyle, id: d, component: a, _jsPlumb: a._jsPlumb.instance
        },
        f = b.extend(e, c); return new (b.Overlays[a._jsPlumb.instance.getRenderMode()].Label)(f);
    },
    f = function (a, d) {
      let e = null; if (c.isArray(d)) {
        let f = d[0],
          g = b.extend({ component: a, _jsPlumb: a._jsPlumb.instance }, d[1]); d.length === 3 && b.extend(g, d[2]), e = new (b.Overlays[a._jsPlumb.instance.getRenderMode()][f])(g);
      } else e = d.constructor === String ? new (b.Overlays[a._jsPlumb.instance.getRenderMode()][d])({ component: a, _jsPlumb: a._jsPlumb.instance }) : d; return e.id = e.id || c.uuid(), a.cacheTypeItem('overlay', e, e.id), a._jsPlumb.overlays[e.id] = e, e;
    }; b.OverlayCapableJsPlumbUIComponent = function (b) {
    a.jsPlumbUIComponent.apply(this, arguments), this._jsPlumb.overlays = {}, this._jsPlumb.overlayPositions = {}, b.label && (this.getDefaultType().overlays[d] = ['Label', {
      label: b.label, location: b.labelLocation || this.defaultLabelLocation || 0.5, labelStyle: b.labelStyle || this._jsPlumb.instance.Defaults.LabelStyle, id: d
    }]), this.setListenerComponent = function (a) { if (this._jsPlumb) for (const b in this._jsPlumb.overlays) this._jsPlumb.overlays[b].setListenerComponent(a); };
  }, b.OverlayCapableJsPlumbUIComponent.applyType = function (a, b) {
    if (b.overlays) {
      let c,
        d = {}; for (c in b.overlays) { const e = a._jsPlumb.overlays[b.overlays[c][1].id]; if (e)e.updateFrom(b.overlays[c][1]), d[b.overlays[c][1].id] = !0; else { let f = a.getCachedTypeItem('overlay', b.overlays[c][1].id); f != null ? (f.reattach(a._jsPlumb.instance, a), f.setVisible(!0), f.updateFrom(b.overlays[c][1]), a._jsPlumb.overlays[f.id] = f) : f = a.addOverlay(b.overlays[c], !0), d[f.id] = !0; } } for (c in a._jsPlumb.overlays)d[a._jsPlumb.overlays[c].id] == null && a.removeOverlay(a._jsPlumb.overlays[c].id, !0);
    }
  }, c.extend(b.OverlayCapableJsPlumbUIComponent, a.jsPlumbUIComponent, {
    setHover(a) { if (this._jsPlumb && !this._jsPlumb.instance.isConnectionBeingDragged()) for (const b in this._jsPlumb.overlays) this._jsPlumb.overlays[b][a ? 'addClass' : 'removeClass'](this._jsPlumb.instance.hoverClass); }, addOverlay(a, b) { const c = f(this, a); return b || this.repaint(), c; }, getOverlay(a) { return this._jsPlumb.overlays[a]; }, getOverlays() { return this._jsPlumb.overlays; }, hideOverlay(a) { const b = this.getOverlay(a); b && b.hide(); }, hideOverlays() { for (const a in this._jsPlumb.overlays) this._jsPlumb.overlays[a].hide(); }, showOverlay(a) { const b = this.getOverlay(a); b && b.show(); }, showOverlays() { for (const a in this._jsPlumb.overlays) this._jsPlumb.overlays[a].show(); }, removeAllOverlays(a) { for (const b in this._jsPlumb.overlays) this._jsPlumb.overlays[b].cleanup && this._jsPlumb.overlays[b].cleanup(); this._jsPlumb.overlays = {}, this._jsPlumb.overlayPositions = null, a || this.repaint(); }, removeOverlay(a, b) { const c = this._jsPlumb.overlays[a]; c && (c.setVisible(!1), !b && c.cleanup && c.cleanup(), delete this._jsPlumb.overlays[a], this._jsPlumb.overlayPositions && delete this._jsPlumb.overlayPositions[a]); }, removeOverlays() { for (let a = 0, b = arguments.length; b > a; a++) this.removeOverlay(arguments[a]); }, moveParent(a) { if (this.bgCanvas && (this.bgCanvas.parentNode.removeChild(this.bgCanvas), a.appendChild(this.bgCanvas)), this.canvas && this.canvas.parentNode) { this.canvas.parentNode.removeChild(this.canvas), a.appendChild(this.canvas); for (const b in this._jsPlumb.overlays) if (this._jsPlumb.overlays[b].isAppendedAtTopLevel) { const c = this._jsPlumb.overlays[b].getElement(); c.parentNode.removeChild(c), a.appendChild(c); } } }, getLabel() { const a = this.getOverlay(d); return a != null ? a.getLabel() : null; }, getLabelOverlay() { return this.getOverlay(d); }, setLabel(a) { let b = this.getOverlay(d); if (b)a.constructor === String || a.constructor === Function ? b.setLabel(a) : (a.label && b.setLabel(a.label), a.location && b.setLocation(a.location)); else { const c = a.constructor === String || a.constructor === Function ? { label: a } : a; b = e(this, c), this._jsPlumb.overlays[d] = b; } this._jsPlumb.instance.isSuspendDrawing() || this.repaint(); }, cleanup(a) { for (const b in this._jsPlumb.overlays) this._jsPlumb.overlays[b].cleanup(a), this._jsPlumb.overlays[b].destroy(a); a && (this._jsPlumb.overlays = {}, this._jsPlumb.overlayPositions = null); }, setVisible(a) { this[a ? 'showOverlays' : 'hideOverlays'](); }, setAbsoluteOverlayPosition(a, b) { this._jsPlumb.overlayPositions[a.id] = b; }, getAbsoluteOverlayPosition(a) { return this._jsPlumb.overlayPositions ? this._jsPlumb.overlayPositions[a.id] : null; }, _clazzManip(a, b, c) { if (!c) for (const d in this._jsPlumb.overlays) this._jsPlumb.overlays[d][`${a}Class`](b); }, addClass(a, b) { this._clazzManip('add', a, b); }, removeClass(a, b) { this._clazzManip('remove', a, b); }
  });
}.call(typeof window !== 'undefined' ? window : this), function () {
  let a = this,
    b = a.jsPlumb,
    c = a.jsPlumbUtil,
    d = function (a, b, c) { let d = !1; return { drag() { if (d) return d = !1, !0; if (b.element) { const e = c.getUIPosition(arguments, c.getZoom()); e != null && c.setPosition(b.element, e), c.repaint(b.element, e), a.paint({ anchorPoint: a.anchor.getCurrentLocation({ element: a }) }); } }, stopDrag() { d = !0; } }; },
    e = function (a, b, c, d) { const e = b.createElement('div', { position: 'absolute' }); b.appendElement(e); const f = b.getId(e); b.setPosition(e, c), e.style.width = `${d[0]}px`, e.style.height = `${d[1]}px`, b.manage(f, e, !0), a.id = f, a.element = e; },
    f = function (a, c, d, e, f, g, h, i) {
      const j = new b.FloatingAnchor({ reference: c, referenceCanvas: e, jsPlumbInstance: g }); return h({
        paintStyle: a, endpoint: d, anchor: j, source: f, scope: i
      });
    },
    g = ['connectorStyle', 'connectorHoverStyle', 'connectorOverlays', 'connector', 'connectionType', 'connectorClass', 'connectorHoverClass'],
    h = function (a, b) { let c = 0; if (b != null) for (let d = 0; d < a.connections.length; d++) if (a.connections[d].sourceId === b || a.connections[d].targetId === b) { c = d; break; } return a.connections[c]; }; b.Endpoint = function (a) {
    let i = a._jsPlumb,
      j = a.newConnection,
      k = a.newEndpoint; this.idPrefix = '_jsplumb_e_', this.defaultLabelLocation = [0.5, 0.5], this.defaultOverlayKeys = ['Overlays', 'EndpointOverlays'], b.OverlayCapableJsPlumbUIComponent.apply(this, arguments), this.appendToDefaultType({
      connectionType: a.connectionType, maxConnections: a.maxConnections == null ? this._jsPlumb.instance.Defaults.MaxConnections : a.maxConnections, paintStyle: a.endpointStyle || a.paintStyle || a.style || this._jsPlumb.instance.Defaults.EndpointStyle || b.Defaults.EndpointStyle, hoverPaintStyle: a.endpointHoverStyle || a.hoverPaintStyle || this._jsPlumb.instance.Defaults.EndpointHoverStyle || b.Defaults.EndpointHoverStyle, connectorStyle: a.connectorStyle, connectorHoverStyle: a.connectorHoverStyle, connectorClass: a.connectorClass, connectorHoverClass: a.connectorHoverClass, connectorOverlays: a.connectorOverlays, connector: a.connector, connectorTooltip: a.connectorTooltip
    }), this._jsPlumb.enabled = !(a.enabled === !1), this._jsPlumb.visible = !0, this.element = b.getElement(a.source), this._jsPlumb.uuid = a.uuid, this._jsPlumb.floatingEndpoint = null; const l = null; this._jsPlumb.uuid && (a.endpointsByUUID[this._jsPlumb.uuid] = this), this.elementId = a.elementId, this.dragProxy = a.dragProxy, this._jsPlumb.connectionCost = a.connectionCost, this._jsPlumb.connectionsDirected = a.connectionsDirected, this._jsPlumb.currentAnchorClass = '', this._jsPlumb.events = {}; let m = a.deleteOnEmpty === !0; this.setDeleteOnEmpty = function (a) { m = a; }; const n = function () { const a = `${i.endpointAnchorClassPrefix}-${this._jsPlumb.currentAnchorClass}`; this._jsPlumb.currentAnchorClass = this.anchor.getCssClass(); const c = i.endpointAnchorClassPrefix + (this._jsPlumb.currentAnchorClass ? `-${this._jsPlumb.currentAnchorClass}` : ''); this.removeClass(a), this.addClass(c), b.updateClasses(this.element, c, a); }.bind(this); this.prepareAnchor = function (a) { const b = this._jsPlumb.instance.makeAnchor(a, this.elementId, i); return b.bind('anchorChanged', (a) => { this.fire('anchorChanged', { endpoint: this, anchor: a }), n(); }), b; }, this.setPreparedAnchor = function (a, b) { return this._jsPlumb.instance.continuousAnchorFactory.clear(this.elementId), this.anchor = a, n(), b || this._jsPlumb.instance.repaint(this.elementId), this; }, this.setAnchor = function (a, b) { const c = this.prepareAnchor(a); return this.setPreparedAnchor(c, b), this; }; const o = function (a) { if (this.connections.length > 0) for (let b = 0; b < this.connections.length; b++) this.connections[b].setHover(a, !1); else this.setHover(a); }.bind(this); this.bind('mouseover', () => { o(!0); }), this.bind('mouseout', () => { o(!1); }), a._transient || this._jsPlumb.instance.anchorManager.add(this, this.elementId), this.prepareEndpoint = function (d, e) {
      let f,
        g = function (a, c) {
          const d = i.getRenderMode(); if (b.Endpoints[d][a]) return new b.Endpoints[d][a](c);
          if (!i.Defaults.DoNotThrowErrors) throw { msg: `jsPlumb: unknown endpoint type '${a}'` };
        },
        h = {
          _jsPlumb: this._jsPlumb.instance, cssClass: a.cssClass, container: a.container, tooltip: a.tooltip, connectorTooltip: a.connectorTooltip, endpoint: this
        }; return c.isString(d) ? f = g(d, h) : c.isArray(d) ? (h = c.merge(d[1], h), f = g(d[0], h)) : f = d.clone(), f.clone = function () { return c.isString(d) ? g(d, h) : c.isArray(d) ? (h = c.merge(d[1], h), g(d[0], h)) : void 0; }, f.typeId = e, f;
    }, this.setEndpoint = function (a) { const b = this.prepareEndpoint(a); this.setPreparedEndpoint(b, !0); }, this.setPreparedEndpoint = function (a) { this.endpoint != null && (this.endpoint.cleanup(), this.endpoint.destroy()), this.endpoint = a, this.type = this.endpoint.type, this.canvas = this.endpoint.canvas; }, b.extend(this, a, g), this.isSource = a.isSource || !1, this.isTemporarySource = a.isTemporarySource || !1, this.isTarget = a.isTarget || !1, this.connections = a.connections || [], this.connectorPointerEvents = a['connector-pointer-events'], this.scope = a.scope || i.getDefaultScope(), this.timestamp = null, this.reattachConnections = a.reattach || i.Defaults.ReattachConnections, this.connectionsDetachable = i.Defaults.ConnectionsDetachable, (a.connectionsDetachable === !1 || a.detachable === !1) && (this.connectionsDetachable = !1), this.dragAllowedWhenFull = a.dragAllowedWhenFull !== !1, a.onMaxConnections && this.bind('maxConnections', a.onMaxConnections), this.addConnection = function (a) { this.connections.push(a), this[`${this.connections.length > 0 ? 'add' : 'remove'}Class`](i.endpointConnectedClass), this[`${this.isFull() ? 'add' : 'remove'}Class`](i.endpointFullClass); }, this.detachFromConnection = function (a, b, c) { b = b == null ? this.connections.indexOf(a) : b, b >= 0 && (this.connections.splice(b, 1), this[`${this.connections.length > 0 ? 'add' : 'remove'}Class`](i.endpointConnectedClass), this[`${this.isFull() ? 'add' : 'remove'}Class`](i.endpointFullClass)), !c && m && this.connections.length === 0 && i.deleteObject({ endpoint: this, fireEvent: !1, deleteAttachedObjects: c !== !0 }); }, this.deleteEveryConnection = function (a) { for (let b = this.connections.length, c = 0; b > c; c++)i.deleteConnection(this.connections[0], a); }, this.detachFrom = function (a) { for (var b = [], c = 0; c < this.connections.length; c++)(this.connections[c].endpoints[1] === a || this.connections[c].endpoints[0] === a) && b.push(this.connections[c]); for (let d = 0, e = b.length; e > d; d++)i.deleteConnection(b[0]); return this; }, this.getElement = function () { return this.element; }, this.setElement = function (d) {
      let e = this._jsPlumb.instance.getId(d),
        f = this.elementId; return c.removeWithFunction(a.endpointsByElement[this.elementId], a => a.id === this.id), this.element = b.getElement(d), this.elementId = i.getId(this.element), i.anchorManager.rehomeEndpoint(this, f, this.element), i.dragManager.endpointAdded(this.element), c.addToList(a.endpointsByElement, e, this), this;
    }, this.makeInPlaceCopy = function () {
      let b = this.anchor.getCurrentLocation({ element: this }),
        c = this.anchor.getOrientation(this),
        d = this.anchor.getCssClass(),
        e = {
          bind() {}, compute() { return [b[0], b[1]]; }, getCurrentLocation() { return [b[0], b[1]]; }, getOrientation() { return c; }, getCssClass() { return d; }
        }; return k({
        dropOptions: a.dropOptions, anchor: e, source: this.element, paintStyle: this.getPaintStyle(), endpoint: a.hideOnDrag ? 'Blank' : this.endpoint, _transient: !0, scope: this.scope, reference: this
      });
    }, this.connectorSelector = function () { const a = this.connections[0]; return a || (this.connections.length < this._jsPlumb.maxConnections || this._jsPlumb.maxConnections === -1 ? null : a); }, this.setStyle = this.setPaintStyle, this.paint = function (a) {
      a = a || {}; let b = a.timestamp,
        c = !(a.recalc === !1); if (!b || this.timestamp !== b) {
        let d = i.updateOffset({ elId: this.elementId, timestamp: b }),
          e = a.offset ? a.offset.o : d.o; if (e != null) {
          let f = a.anchorPoint,
            g = a.connectorPaintStyle; if (f == null) {
            let j = a.dimensions || d.s,
              k = {
                xy: [e.left, e.top], wh: j, element: this, timestamp: b
              }; if (c && this.anchor.isDynamic && this.connections.length > 0) {
              let l = h(this, a.elementWithPrecedence),
                m = l.endpoints[0] === this ? 1 : 0,
                n = m === 0 ? l.sourceId : l.targetId,
                o = i.getCachedData(n),
                p = o.o,
                q = o.s; k.index = m === 0 ? 1 : 0, k.connection = l, k.txy = [p.left, p.top], k.twh = q, k.tElement = l.endpoints[m];
            }f = this.anchor.compute(k);
          } this.endpoint.compute(f, this.anchor.getOrientation(this), this._jsPlumb.paintStyleInUse, g || this.paintStyleInUse), this.endpoint.paint(this._jsPlumb.paintStyleInUse, this.anchor), this.timestamp = b; for (const r in this._jsPlumb.overlays) if (this._jsPlumb.overlays.hasOwnProperty(r)) { const s = this._jsPlumb.overlays[r]; s.isVisible() && (this._jsPlumb.overlayPlacements[r] = s.draw(this.endpoint, this._jsPlumb.paintStyleInUse), s.paint(this._jsPlumb.overlayPlacements[r])); }
        }
      }
    }, this.getTypeDescriptor = function () { return 'endpoint'; }, this.isVisible = function () { return this._jsPlumb.visible; }, this.repaint = this.paint; let p = !1; this.initDraggable = function () {
      if (!p && b.isDragSupported(this.element)) {
        let g,
          h = { id: null, element: null },
          m = null,
          n = !1,
          o = null,
          q = d(this, h, i),
          r = a.dragOptions || {},
          s = {},
          t = b.dragEvents.start,
          u = b.dragEvents.stop,
          v = b.dragEvents.drag,
          w = b.dragEvents.beforeStart,
          x = function (a) { g = a.e.payload || {}; },
          y = function () {
            m = this.connectorSelector(); let d = !0; this.isEnabled() || (d = !1), m != null || this.isSource || this.isTemporarySource || (d = !1), !this.isSource || !this.isFull() || m != null && this.dragAllowedWhenFull || (d = !1), m == null || m.isDetachable(this) || (d = !1); let l = i.checkCondition(m == null ? 'beforeDrag' : 'beforeStartDetach', {
              endpoint: this, source: this.element, sourceId: this.elementId, connection: m
            }); if (l === !1 ? d = !1 : typeof l === 'object' ? b.extend(l, g || {}) : l = g || {}, d === !1) return i.stopDrag && i.stopDrag(this.canvas), q.stopDrag(), !1; for (let p = 0; p < this.connections.length; p++) this.connections[p].setHover(!1); this.addClass('endpointDrag'), i.setConnectionBeingDragged(!0), m && !this.isFull() && this.isSource && (m = null), i.updateOffset({ elId: this.elementId }); let r = this._jsPlumb.instance.getOffset(this.canvas),
              s = this.canvas,
              t = this._jsPlumb.instance.getSize(this.canvas); e(h, i, r, t), i.setAttributes(this.canvas, { dragId: h.id, elId: this.elementId }); let u = this.dragProxy || this.endpoint; if (this.dragProxy == null && this.connectionType != null) { const v = this._jsPlumb.instance.deriveEndpointAndAnchorSpec(this.connectionType); v.endpoints[1] && (u = v.endpoints[1]); } const w = this._jsPlumb.instance.makeAnchor('Center'); w.isFloating = !0, this._jsPlumb.floatingEndpoint = f(this.getPaintStyle(), w, u, this.canvas, h.element, i, k, this.scope); const x = this._jsPlumb.floatingEndpoint.anchor; if (m == null) {
              this.setHover(!1, !1), m = j({
                sourceEndpoint: this, targetEndpoint: this._jsPlumb.floatingEndpoint, source: this.element, target: h.element, anchors: [this.anchor, this._jsPlumb.floatingEndpoint.anchor], paintStyle: a.connectorStyle, hoverPaintStyle: a.connectorHoverStyle, connector: a.connector, overlays: a.connectorOverlays, type: this.connectionType, cssClass: this.connectorClass, hoverClass: this.connectorHoverClass, scope: a.scope, data: l
              }), m.pending = !0, m.addClass(i.draggingClass), this._jsPlumb.floatingEndpoint.addClass(i.draggingClass), this._jsPlumb.floatingEndpoint.anchor = x, i.fire('connectionDrag', m), i.anchorManager.newConnection(m);
            } else { n = !0, m.setHover(!1); const y = m.endpoints[0].id === this.id ? 0 : 1; this.detachFromConnection(m, null, !0); const z = i.getDragScope(s); i.setAttribute(this.canvas, 'originalScope', z), i.fire('connectionDrag', m), y === 0 ? (o = [m.source, m.sourceId, s, z], i.anchorManager.sourceChanged(m.endpoints[y].elementId, h.id, m, h.element)) : (o = [m.target, m.targetId, s, z], m.target = h.element, m.targetId = h.id, i.anchorManager.updateOtherEndpoint(m.sourceId, m.endpoints[y].elementId, m.targetId, m)), m.suspendedEndpoint = m.endpoints[y], m.suspendedElement = m.endpoints[y].getElement(), m.suspendedElementId = m.endpoints[y].elementId, m.suspendedElementType = y === 0 ? 'source' : 'target', m.suspendedEndpoint.setHover(!1), this._jsPlumb.floatingEndpoint.referenceEndpoint = m.suspendedEndpoint, m.endpoints[y] = this._jsPlumb.floatingEndpoint, m.addClass(i.draggingClass), this._jsPlumb.floatingEndpoint.addClass(i.draggingClass); }i.floatingConnections[h.id] = m, c.addToList(a.endpointsByElement, h.id, this._jsPlumb.floatingEndpoint), i.currentlyDragging = !0;
          }.bind(this),
          z = function () {
            if (i.setConnectionBeingDragged(!1), m && m.endpoints != null) {
              let a = i.getDropEvent(arguments),
                b = i.getFloatingAnchorIndex(m); if (m.endpoints[b === 0 ? 1 : 0].anchor.locked = !1, m.removeClass(i.draggingClass), this._jsPlumb && (m.deleteConnectionNow || m.endpoints[b] === this._jsPlumb.floatingEndpoint) && n && m.suspendedEndpoint) { b === 0 ? (m.floatingElement = m.source, m.floatingId = m.sourceId, m.floatingEndpoint = m.endpoints[0], m.floatingIndex = 0, m.source = o[0], m.sourceId = o[1]) : (m.floatingElement = m.target, m.floatingId = m.targetId, m.floatingEndpoint = m.endpoints[1], m.floatingIndex = 1, m.target = o[0], m.targetId = o[1]); const c = this._jsPlumb.floatingEndpoint; i.setDragScope(o[2], o[3]), m.endpoints[b] = m.suspendedEndpoint, m.isReattach() || m._forceReattach || m._forceDetach || !i.deleteConnection(m, { originalEvent: a }) ? (m.setHover(!1), m._forceDetach = null, m._forceReattach = null, this._jsPlumb.floatingEndpoint.detachFromConnection(m), m.suspendedEndpoint.addConnection(m), b === 1 ? i.anchorManager.updateOtherEndpoint(m.sourceId, m.floatingId, m.targetId, m) : i.anchorManager.sourceChanged(m.floatingId, m.sourceId, m, m.source), i.repaint(o[1])) : i.deleteObject({ endpoint: c }); } this.deleteAfterDragStop ? i.deleteObject({ endpoint: this }) : this._jsPlumb && this.paint({ recalc: !1 }), i.fire('connectionDragStop', m, a), m.pending && i.fire('connectionAborted', m, a), i.currentlyDragging = !1, m.suspendedElement = null, m.suspendedEndpoint = null, m = null;
            }h && h.element && i.remove(h.element, !1, !1), l && i.deleteObject({ endpoint: l }), this._jsPlumb && (this.canvas.style.visibility = 'visible', this.anchor.locked = !1, this._jsPlumb.floatingEndpoint = null);
          }.bind(this); r = b.extend(s, r), r.scope = this.scope || r.scope, r[w] = c.wrap(r[w], x, !1), r[t] = c.wrap(r[t], y, !1), r[v] = c.wrap(r[v], q.drag), r[u] = c.wrap(r[u], z), r.multipleDrop = !1, r.canDrag = function () { return this.isSource || this.isTemporarySource || this.connections.length > 0; }.bind(this), i.initDraggable(this.canvas, r, 'internal'), this.canvas._jsPlumbRelatedElement = this.element, p = !0;
      }
    }; const q = a.endpoint || this._jsPlumb.instance.Defaults.Endpoint || b.Defaults.Endpoint; this.setEndpoint(q, !0); const r = a.anchor ? a.anchor : a.anchors ? a.anchors : i.Defaults.Anchor || 'Top'; this.setAnchor(r, !0); const s = ['default', a.type || ''].join(' '); this.addType(s, a.data, !0), this.canvas = this.endpoint.canvas, this.canvas._jsPlumb = this, this.initDraggable(); const t = function (d, e, f, g) {
      if (b.isDropSupported(this.element)) {
        let h = a.dropOptions || i.Defaults.DropOptions || b.Defaults.DropOptions; h = b.extend({}, h), h.scope = h.scope || this.scope; let j = b.dragEvents.drop,
          k = b.dragEvents.over,
          l = b.dragEvents.out,
          m = this,
          n = i.EndpointDropHandler({
            getEndpoint() { return m; }, jsPlumb: i, enabled() { return f != null ? f.isEnabled() : !0; }, isFull() { return f.isFull(); }, element: this.element, elementId: this.elementId, isSource: this.isSource, isTarget: this.isTarget, addClass(a) { m.addClass(a); }, removeClass(a) { m.removeClass(a); }, isDropAllowed() { return m.isDropAllowed(...arguments); }, reference: g, isRedrop(a, b) { return a.suspendedEndpoint && b.reference && a.suspendedEndpoint.id === b.reference.id; }
          }); h[j] = c.wrap(h[j], n, !0), h[k] = c.wrap(h[k], function () {
          let a = b.getDragObject(arguments),
            c = i.getAttribute(b.getElement(a), 'dragId'),
            d = i.floatingConnections[c]; if (d != null) {
            let e = i.getFloatingAnchorIndex(d),
              f = this.isTarget && e !== 0 || d.suspendedEndpoint && this.referenceEndpoint && this.referenceEndpoint.id === d.suspendedEndpoint.id; if (f) { const g = i.checkCondition('checkDropAllowed', { sourceEndpoint: d.endpoints[e], targetEndpoint: this, connection: d }); this[`${g ? 'add' : 'remove'}Class`](i.endpointDropAllowedClass), this[`${g ? 'remove' : 'add'}Class`](i.endpointDropForbiddenClass), d.endpoints[e].anchor.over(this.anchor, this); }
          }
        }.bind(this)), h[l] = c.wrap(h[l], function () {
          let a = b.getDragObject(arguments),
            c = a == null ? null : i.getAttribute(b.getElement(a), 'dragId'),
            d = c ? i.floatingConnections[c] : null; if (d != null) {
            let e = i.getFloatingAnchorIndex(d),
              f = this.isTarget && e !== 0 || d.suspendedEndpoint && this.referenceEndpoint && this.referenceEndpoint.id === d.suspendedEndpoint.id; f && (this.removeClass(i.endpointDropAllowedClass), this.removeClass(i.endpointDropForbiddenClass), d.endpoints[e].anchor.out());
          }
        }.bind(this)), i.initDroppable(d, h, 'internal', e);
      }
    }.bind(this); return this.anchor.isFloating || t(this.canvas, !(a._transient || this.anchor.isFloating), this, a.reference), this;
  }, c.extend(b.Endpoint, b.OverlayCapableJsPlumbUIComponent, {
    setVisible(a, b, c) { if (this._jsPlumb.visible = a, this.canvas && (this.canvas.style.display = a ? 'block' : 'none'), this[a ? 'showOverlays' : 'hideOverlays'](), !b) for (let d = 0; d < this.connections.length; d++) if (this.connections[d].setVisible(a), !c) { const e = this === this.connections[d].endpoints[0] ? 1 : 0; this.connections[d].endpoints[e].connections.length === 1 && this.connections[d].endpoints[e].setVisible(a, !0, !0); } }, getAttachedElements() { return this.connections; }, applyType(a, c) { this.setPaintStyle(a.endpointStyle || a.paintStyle, c), this.setHoverPaintStyle(a.endpointHoverStyle || a.hoverPaintStyle, c), a.maxConnections != null && (this._jsPlumb.maxConnections = a.maxConnections), a.scope && (this.scope = a.scope), b.extend(this, a, g), a.cssClass != null && this.canvas && this._jsPlumb.instance.addClass(this.canvas, a.cssClass), b.OverlayCapableJsPlumbUIComponent.applyType(this, a); }, isEnabled() { return this._jsPlumb.enabled; }, setEnabled(a) { this._jsPlumb.enabled = a; }, cleanup() { const a = this._jsPlumb.instance.endpointAnchorClassPrefix + (this._jsPlumb.currentAnchorClass ? `-${this._jsPlumb.currentAnchorClass}` : ''); b.removeClass(this.element, a), this.anchor = null, this.endpoint.cleanup(!0), this.endpoint.destroy(), this.endpoint = null, this._jsPlumb.instance.destroyDraggable(this.canvas, 'internal'), this._jsPlumb.instance.destroyDroppable(this.canvas, 'internal'); }, setHover(a) { this.endpoint && this._jsPlumb && !this._jsPlumb.instance.isConnectionBeingDragged() && this.endpoint.setHover(a); }, isFull() { return this._jsPlumb.maxConnections === 0 ? !0 : !(this.isFloating() || this._jsPlumb.maxConnections < 0 || this.connections.length < this._jsPlumb.maxConnections); }, isFloating() { return this.anchor != null && this.anchor.isFloating; }, isConnectedTo(a) { let b = !1; if (a) for (let c = 0; c < this.connections.length; c++) if (this.connections[c].endpoints[1] === a || this.connections[c].endpoints[0] === a) { b = !0; break; } return b; }, getConnectionCost() { return this._jsPlumb.connectionCost; }, setConnectionCost(a) { this._jsPlumb.connectionCost = a; }, areConnectionsDirected() { return this._jsPlumb.connectionsDirected; }, setConnectionsDirected(a) { this._jsPlumb.connectionsDirected = a; }, setElementId(a) { this.elementId = a, this.anchor.elementId = a; }, setReferenceElement(a) { this.element = b.getElement(a); }, setDragAllowedWhenFull(a) { this.dragAllowedWhenFull = a; }, equals(a) { return this.anchor.equals(a.anchor); }, getUuid() { return this._jsPlumb.uuid; }, computeAnchor(a) { return this.anchor.compute(a); }
  }), a.jsPlumbInstance.prototype.EndpointDropHandler = function (a) {
    return function (b) {
      const d = a.jsPlumb; a.removeClass(d.endpointDropAllowedClass), a.removeClass(d.endpointDropForbiddenClass); let e = d.getDropEvent(arguments),
        f = d.getDragObject(arguments),
        g = d.getAttribute(f, 'dragId'),
        h = (d.getAttribute(f, 'elId'), d.getAttribute(f, 'originalScope')),
        i = d.floatingConnections[g]; if (i != null) {
        const j = i.suspendedEndpoint != null; if (!j || i.suspendedEndpoint._jsPlumb != null) {
          const k = a.getEndpoint(i); if (k != null) {
            if (a.isRedrop(i, a)) return i._forceReattach = !0, i.setHover(!1), a.maybeCleanup && a.maybeCleanup(k), void 0; const l = d.getFloatingAnchorIndex(i); if (l === 0 && !a.isSource || l === 1 && !a.isTarget) return a.maybeCleanup && a.maybeCleanup(k), void 0; a.onDrop && a.onDrop(i), h && d.setDragScope(f, h); const m = a.isFull(b); if (m && k.fire('maxConnections', { endpoint: this, connection: i, maxConnections: k._jsPlumb.maxConnections }, e), !m && a.enabled()) {
              let n = !0; l === 0 ? (i.floatingElement = i.source, i.floatingId = i.sourceId, i.floatingEndpoint = i.endpoints[0], i.floatingIndex = 0, i.source = a.element, i.sourceId = a.elementId) : (i.floatingElement = i.target, i.floatingId = i.targetId, i.floatingEndpoint = i.endpoints[1], i.floatingIndex = 1, i.target = a.element, i.targetId = a.elementId), j && i.suspendedEndpoint.id !== k.id && (i.isDetachAllowed(i) && i.endpoints[l].isDetachAllowed(i) && i.suspendedEndpoint.isDetachAllowed(i) && d.checkCondition('beforeDetach', i) || (n = !1)); let o = function (b) {
                  i.endpoints[l].detachFromConnection(i), i.suspendedEndpoint && i.suspendedEndpoint.detachFromConnection(i), i.endpoints[l] = k, k.addConnection(i); const f = k.getParameters(); for (const g in f)i.setParameter(g, f[g]); if (j) {
                    const h = i.suspendedEndpoint.elementId; d.fireMoveEvent({
                      index: l, originalSourceId: l === 0 ? h : i.sourceId, newSourceId: l === 0 ? k.elementId : i.sourceId, originalTargetId: l === 1 ? h : i.targetId, newTargetId: l === 1 ? k.elementId : i.targetId, originalSourceEndpoint: l === 0 ? i.suspendedEndpoint : i.endpoints[0], newSourceEndpoint: l === 0 ? k : i.endpoints[0], originalTargetEndpoint: l === 1 ? i.suspendedEndpoint : i.endpoints[1], newTargetEndpoint: l === 1 ? k : i.endpoints[1], connection: i
                    }, e);
                  } else f.draggable && d.initDraggable(this.element, a.dragOptions, 'internal', d); if (l === 1 ? d.anchorManager.updateOtherEndpoint(i.sourceId, i.floatingId, i.targetId, i) : d.anchorManager.sourceChanged(i.floatingId, i.sourceId, i, i.source), i.endpoints[0].finalEndpoint) { const m = i.endpoints[0]; m.detachFromConnection(i), i.endpoints[0] = i.endpoints[0].finalEndpoint, i.endpoints[0].addConnection(i); }c.isObject(b) && i.mergeData(b), d.finaliseConnection(i, null, e, !1), i.setHover(!1);
                }.bind(this),
                p = function () { i.suspendedEndpoint && (i.endpoints[l] = i.suspendedEndpoint, i.setHover(!1), i._forceDetach = !0, l === 0 ? (i.source = i.suspendedEndpoint.element, i.sourceId = i.suspendedEndpoint.elementId) : (i.target = i.suspendedEndpoint.element, i.targetId = i.suspendedEndpoint.elementId), i.suspendedEndpoint.addConnection(i), l === 1 ? d.anchorManager.updateOtherEndpoint(i.sourceId, i.floatingId, i.targetId, i) : d.anchorManager.sourceChanged(i.floatingId, i.sourceId, i, i.source), d.repaint(i.sourceId), i._forceDetach = !1); }; if (n = n && a.isDropAllowed(i.sourceId, i.targetId, i.scope, i, k)) return o(n), !0; p();
            }a.maybeCleanup && a.maybeCleanup(k), d.currentlyDragging = !1;
          }
        }
      }
    };
  };
}.call(typeof window !== 'undefined' ? window : this), function () {
  let a = this,
    b = a.jsPlumb,
    c = a.jsPlumbUtil,
    d = function (a, c, d, e, f) { if (!a.Defaults.DoNotThrowErrors && b.Connectors[c][d] == null) throw { msg: `jsPlumb: unknown connector type '${d}'` }; return new b.Connectors[c][d](e, f); },
    e = function (a, b, c) { return a ? c.makeAnchor(a, b, c) : null; },
    f = function (a, b, d, e) { b != null && (b._jsPlumbConnections = b._jsPlumbConnections || {}, e ? delete b._jsPlumbConnections[a.id] : b._jsPlumbConnections[a.id] = !0, c.isEmpty(b._jsPlumbConnections) ? d.removeClass(b, d.connectedClass) : d.addClass(b, d.connectedClass)); }; b.Connection = function (a) {
    const d = a.newEndpoint; this.id = a.id, this.connector = null, this.idPrefix = '_jsplumb_c_', this.defaultLabelLocation = 0.5, this.defaultOverlayKeys = ['Overlays', 'ConnectionOverlays'], this.previousConnection = a.previousConnection, this.source = b.getElement(a.source), this.target = b.getElement(a.target), a.sourceEndpoint && (this.source = a.sourceEndpoint.getElement()), a.targetEndpoint && (this.target = a.targetEndpoint.getElement()), b.OverlayCapableJsPlumbUIComponent.apply(this, arguments), this.sourceId = this._jsPlumb.instance.getId(this.source), this.targetId = this._jsPlumb.instance.getId(this.target), this.scope = a.scope, this.endpoints = [], this.endpointStyles = []; const e = this._jsPlumb.instance; e.manage(this.sourceId, this.source), e.manage(this.targetId, this.target), this._jsPlumb.visible = !0, this._jsPlumb.editable = a.editable === !0, this._jsPlumb.params = {
      cssClass: a.cssClass, container: a.container, 'pointer-events': a['pointer-events'], editorParams: a.editorParams, overlays: a.overlays
    }, this._jsPlumb.lastPaintedAt = null, this.bind('mouseover', () => { this.setHover(!0); }), this.bind('mouseout', () => { this.setHover(!1); }), this.editableRequested = a.editable !== !1, this.setEditable = function (a) { return this.connector ? this.connector.setEditable(a) : !1; }, this.isEditable = function () { return this.connector ? this.connector.isEditable() : !1; }, this.isEditing = function () { return this.connector ? this.connector.isEditing() : !1; }, this.makeEndpoint = function (b, c, f, g) { return f = f || this._jsPlumb.instance.getId(c), this.prepareEndpoint(e, d, this, g, b ? 0 : 1, a, c, f); }, a.type && (a.endpoints = a.endpoints || this._jsPlumb.instance.deriveEndpointAndAnchorSpec(a.type).endpoints); let f = this.makeEndpoint(!0, this.source, this.sourceId, a.sourceEndpoint),
      g = this.makeEndpoint(!1, this.target, this.targetId, a.targetEndpoint); f && c.addToList(a.endpointsByElement, this.sourceId, f), g && c.addToList(a.endpointsByElement, this.targetId, g), this.scope || (this.scope = this.endpoints[0].scope), a.deleteEndpointsOnEmpty != null && (this.endpoints[0].setDeleteOnEmpty(a.deleteEndpointsOnEmpty), this.endpoints[1].setDeleteOnEmpty(a.deleteEndpointsOnEmpty)); let h = e.Defaults.ConnectionsDetachable; a.detachable === !1 && (h = !1), this.endpoints[0].connectionsDetachable === !1 && (h = !1), this.endpoints[1].connectionsDetachable === !1 && (h = !1); const i = a.reattach || this.endpoints[0].reattachConnections || this.endpoints[1].reattachConnections || e.Defaults.ReattachConnections; this.appendToDefaultType({
      detachable: h, reattach: i, paintStyle: this.endpoints[0].connectorStyle || this.endpoints[1].connectorStyle || a.paintStyle || e.Defaults.PaintStyle || b.Defaults.PaintStyle, hoverPaintStyle: this.endpoints[0].connectorHoverStyle || this.endpoints[1].connectorHoverStyle || a.hoverPaintStyle || e.Defaults.HoverPaintStyle || b.Defaults.HoverPaintStyle
    }); const j = e.getSuspendedAt(); if (!e.isSuspendDrawing()) {
      let k = e.getCachedData(this.sourceId),
        l = k.o,
        m = k.s,
        n = e.getCachedData(this.targetId),
        o = n.o,
        p = n.s,
        q = j || e.timestamp(),
        r = this.endpoints[0].anchor.compute({
          xy: [l.left, l.top], wh: m, element: this.endpoints[0], elementId: this.endpoints[0].elementId, txy: [o.left, o.top], twh: p, tElement: this.endpoints[1], timestamp: q
        }); this.endpoints[0].paint({ anchorLoc: r, timestamp: q }), r = this.endpoints[1].anchor.compute({
        xy: [o.left, o.top], wh: p, element: this.endpoints[1], elementId: this.endpoints[1].elementId, txy: [l.left, l.top], twh: m, tElement: this.endpoints[0], timestamp: q
      }), this.endpoints[1].paint({ anchorLoc: r, timestamp: q });
    } this.getTypeDescriptor = function () { return 'connection'; }, this.getAttachedElements = function () { return this.endpoints; }, this.isDetachable = function () { return this._jsPlumb.detachable === !0; }, this.setDetachable = function (a) { this._jsPlumb.detachable = a === !0; }, this.isReattach = function () { return this._jsPlumb.reattach === !0 || this.endpoints[0].reattachConnections === !0 || this.endpoints[1].reattachConnections === !0; }, this.setReattach = function (a) { this._jsPlumb.reattach = a === !0; }, this._jsPlumb.cost = a.cost || this.endpoints[0].getConnectionCost(), this._jsPlumb.directed = a.directed, a.directed == null && (this._jsPlumb.directed = this.endpoints[0].areConnectionsDirected()); const s = b.extend({}, this.endpoints[1].getParameters()); b.extend(s, this.endpoints[0].getParameters()), b.extend(s, this.getParameters()), this.setParameters(s), this.setConnector(this.endpoints[0].connector || this.endpoints[1].connector || a.connector || e.Defaults.Connector || b.Defaults.Connector, !0), a.geometry && this.connector.setGeometry(a.geometry); let t = a.data != null && c.isObject(a.data) ? a.data : {}; this.getData = function () { return t; }, this.setData = function (a) { t = a || {}; }, this.mergeData = function (a) { t = b.extend(t, a); }; const u = ['default', this.endpoints[0].connectionType, this.endpoints[1].connectionType, a.type].join(' '); /[^\s]/.test(u) && this.addType(u, a.data, !0), this.updateConnectedClass();
  }, c.extend(b.Connection, b.OverlayCapableJsPlumbUIComponent, {
    applyType(a, c, d) { let e = null; a.connector != null && (e = this.getCachedTypeItem('connector', d.connector), e == null && (e = this.prepareConnector(a.connector, d.connector), this.cacheTypeItem('connector', e, d.connector)), this.setPreparedConnector(e)), a.detachable != null && this.setDetachable(a.detachable), a.reattach != null && this.setReattach(a.reattach), a.scope && (this.scope = a.scope), a.cssClass != null && this.canvas && this._jsPlumb.instance.addClass(this.canvas, a.cssClass); let f = null; a.anchor ? (f = this.getCachedTypeItem('anchors', d.anchor), f == null && (f = [this._jsPlumb.instance.makeAnchor(a.anchor), this._jsPlumb.instance.makeAnchor(a.anchor)], this.cacheTypeItem('anchors', f, d.anchor))) : a.anchors && (f = this.getCachedTypeItem('anchors', d.anchors), f == null && (f = [this._jsPlumb.instance.makeAnchor(a.anchors[0]), this._jsPlumb.instance.makeAnchor(a.anchors[1])], this.cacheTypeItem('anchors', f, d.anchors))), f != null && (this.endpoints[0].anchor = f[0], this.endpoints[1].anchor = f[1], this.endpoints[1].anchor.isDynamic && this._jsPlumb.instance.repaint(this.endpoints[1].elementId)), b.OverlayCapableJsPlumbUIComponent.applyType(this, a); },
    addClass(a, b) { b && (this.endpoints[0].addClass(a), this.endpoints[1].addClass(a), this.suspendedEndpoint && this.suspendedEndpoint.addClass(a)), this.connector && this.connector.addClass(a); },
    removeClass(a, b) { b && (this.endpoints[0].removeClass(a), this.endpoints[1].removeClass(a), this.suspendedEndpoint && this.suspendedEndpoint.removeClass(a)), this.connector && this.connector.removeClass(a); },
    isVisible() { return this._jsPlumb.visible; },
    setVisible(a) { this._jsPlumb.visible = a, this.connector && this.connector.setVisible(a), this.repaint(); },
    cleanup() { this.updateConnectedClass(!0), this.endpoints = null, this.source = null, this.target = null, this.connector != null && (this.connector.cleanup(!0), this.connector.destroy(!0)), this.connector = null; },
    updateConnectedClass(a) { this._jsPlumb && (f(this, this.source, this._jsPlumb.instance, a), f(this, this.target, this._jsPlumb.instance, a)); },
    setHover(b) { this.connector && this._jsPlumb && !this._jsPlumb.instance.isConnectionBeingDragged() && (this.connector.setHover(b), a.jsPlumb[b ? 'addClass' : 'removeClass'](this.source, this._jsPlumb.instance.hoverSourceClass), a.jsPlumb[b ? 'addClass' : 'removeClass'](this.target, this._jsPlumb.instance.hoverTargetClass)); },
    getUuids() { return [this.endpoints[0].getUuid(), this.endpoints[1].getUuid()]; },
    getCost() { return this._jsPlumb ? this._jsPlumb.cost : -1 / 0; },
    setCost(a) { this._jsPlumb.cost = a; },
    isDirected() { return this._jsPlumb.directed === !0; },
    getConnector() { return this.connector; },
    getGeometry() { return this.connector ? this.connector.getGeometry() : null; },
    setGeometry(a) { this.connector && this.connector.setGeometry(a); },
    prepareConnector(a, b) {
      let e,
        f = {
          _jsPlumb: this._jsPlumb.instance, cssClass: (this._jsPlumb.params.cssClass || '') + (this.isEditable() ? this._jsPlumb.instance.editableConnectorClass : ''), container: this._jsPlumb.params.container, 'pointer-events': this._jsPlumb.params['pointer-events'], editable: this.editableRequested
        },
        g = this._jsPlumb.instance.getRenderMode(); return c.isString(a) ? e = d(this._jsPlumb.instance, g, a, f, this) : c.isArray(a) && (e = a.length === 1 ? d(this._jsPlumb.instance, g, a[0], f, this) : d(this._jsPlumb.instance, g, a[0], c.merge(a[1], f), this)), b != null && (e.typeId = b), e;
    },
    setPreparedConnector(a, b, c, d) {
      let e,
        f = ''; if (this.connector != null && (e = this.connector, f = e.getClass(), this.connector.cleanup(), this.connector.destroy()), this.connector = a, d && this.cacheTypeItem('connector', a, d), this.canvas = this.connector.canvas, this.bgCanvas = this.connector.bgCanvas, this.addClass(f), this.canvas && (this.canvas._jsPlumb = this), this.bgCanvas && (this.bgCanvas._jsPlumb = this), e != null) for (let g = this.getOverlays(), h = 0; h < g.length; h++)g[h].transfer && g[h].transfer(this.connector); c || this.setListenerComponent(this.connector), b || this.repaint();
    },
    setConnector(a, b, c, d) { const e = this.prepareConnector(a, d); this.setPreparedConnector(e, b, c, d); },
    paint(a) {
      if (!this._jsPlumb.instance.isSuspendDrawing() && this._jsPlumb.visible) {
        a = a || {}; let b = a.timestamp,
          c = !1,
          d = c ? this.sourceId : this.targetId,
          e = c ? this.targetId : this.sourceId,
          f = c ? 0 : 1,
          g = c ? 1 : 0; if (b == null || b !== this._jsPlumb.lastPaintedAt) {
          let h = this._jsPlumb.instance.updateOffset({ elId: e }).o,
            i = this._jsPlumb.instance.updateOffset({ elId: d }).o,
            j = this.endpoints[g],
            k = this.endpoints[f],
            l = j.anchor.getCurrentLocation({
              xy: [h.left, h.top], wh: [h.width, h.height], element: j, timestamp: b
            }),
            m = k.anchor.getCurrentLocation({
              xy: [i.left, i.top], wh: [i.width, i.height], element: k, timestamp: b
            }); this.connector.resetBounds(), this.connector.compute({
            sourcePos: l, targetPos: m, sourceEndpoint: this.endpoints[g], targetEndpoint: this.endpoints[f], 'stroke-width': this._jsPlumb.paintStyleInUse.strokeWidth, sourceInfo: h, targetInfo: i
          }); const n = {
            minX: 1 / 0, minY: 1 / 0, maxX: -1 / 0, maxY: -1 / 0
          }; for (const o in this._jsPlumb.overlays) if (this._jsPlumb.overlays.hasOwnProperty(o)) { const p = this._jsPlumb.overlays[o]; p.isVisible() && (this._jsPlumb.overlayPlacements[o] = p.draw(this.connector, this._jsPlumb.paintStyleInUse, this.getAbsoluteOverlayPosition(p)), n.minX = Math.min(n.minX, this._jsPlumb.overlayPlacements[o].minX), n.maxX = Math.max(n.maxX, this._jsPlumb.overlayPlacements[o].maxX), n.minY = Math.min(n.minY, this._jsPlumb.overlayPlacements[o].minY), n.maxY = Math.max(n.maxY, this._jsPlumb.overlayPlacements[o].maxY)); } let q = parseFloat(this._jsPlumb.paintStyleInUse.strokeWidth || 1) / 2,
            r = parseFloat(this._jsPlumb.paintStyleInUse.strokeWidth || 0),
            s = {
              xmin: Math.min(this.connector.bounds.minX - (q + r), n.minX), ymin: Math.min(this.connector.bounds.minY - (q + r), n.minY), xmax: Math.max(this.connector.bounds.maxX + (q + r), n.maxX), ymax: Math.max(this.connector.bounds.maxY + (q + r), n.maxY)
            }; this.connector.paint(this._jsPlumb.paintStyleInUse, null, s); for (const t in this._jsPlumb.overlays) if (this._jsPlumb.overlays.hasOwnProperty(t)) { const u = this._jsPlumb.overlays[t]; u.isVisible() && u.paint(this._jsPlumb.overlayPlacements[t], s); }
        } this._jsPlumb.lastPaintedAt = b;
      }
    },
    repaint(a) { a = a || {}, this.paint({ elId: this.sourceId, recalc: !(a.recalc === !1), timestamp: a.timestamp }); },
    prepareEndpoint(a, c, d, f, g, h, i, j) {
      let k; if (f)d.endpoints[g] = f, f.addConnection(d); else {
        h.endpoints || (h.endpoints = [null, null]); const l = h.endpoints[g] || h.endpoint || a.Defaults.Endpoints[g] || b.Defaults.Endpoints[g] || a.Defaults.Endpoint || b.Defaults.Endpoint; h.endpointStyles || (h.endpointStyles = [null, null]), h.endpointHoverStyles || (h.endpointHoverStyles = [null, null]); const m = h.endpointStyles[g] || h.endpointStyle || a.Defaults.EndpointStyles[g] || b.Defaults.EndpointStyles[g] || a.Defaults.EndpointStyle || b.Defaults.EndpointStyle; m.fill == null && h.paintStyle != null && (m.fill = h.paintStyle.stroke), m.outlineStroke == null && h.paintStyle != null && (m.outlineStroke = h.paintStyle.outlineStroke), m.outlineWidth == null && h.paintStyle != null && (m.outlineWidth = h.paintStyle.outlineWidth); let n = h.endpointHoverStyles[g] || h.endpointHoverStyle || a.Defaults.EndpointHoverStyles[g] || b.Defaults.EndpointHoverStyles[g] || a.Defaults.EndpointHoverStyle || b.Defaults.EndpointHoverStyle; h.hoverPaintStyle != null && (n == null && (n = {}), n.fill == null && (n.fill = h.hoverPaintStyle.stroke)); let o = h.anchors ? h.anchors[g] : h.anchor ? h.anchor : e(a.Defaults.Anchors[g], j, a) || e(b.Defaults.Anchors[g], j, a) || e(a.Defaults.Anchor, j, a) || e(b.Defaults.Anchor, j, a),
          p = h.uuids ? h.uuids[g] : null; k = c({
          paintStyle: m, hoverPaintStyle: n, endpoint: l, connections: [d], uuid: p, anchor: o, source: i, scope: h.scope, reattach: h.reattach || a.Defaults.ReattachConnections, detachable: h.detachable || a.Defaults.ConnectionsDetachable
        }), f == null && k.setDeleteOnEmpty(!0), d.endpoints[g] = k, h.drawEndpoints === !1 && k.setVisible(!1, !0, !0);
      } return k;
    }
  });
}.call(typeof window !== 'undefined' ? window : this), function () {
  let a = this,
    b = a.jsPlumbUtil,
    c = a.jsPlumb; c.AnchorManager = function (a) {
    let d = {},
      e = {},
      f = {},
      g = {},
      h = {
        HORIZONTAL: 'horizontal', VERTICAL: 'vertical', DIAGONAL: 'diagonal', IDENTITY: 'identity'
      },
      i = ['left', 'top', 'right', 'bottom'],
      j = {},
      k = this,
      l = {},
      m = a.jsPlumbInstance,
      n = {},
      o = function (a, b, c, d, e, f) {
        if (a === b) return { orientation: h.IDENTITY, a: ['top', 'top'] }; let g = Math.atan2(d.centery - c.centery, d.centerx - c.centerx),
          j = Math.atan2(c.centery - d.centery, c.centerx - d.centerx),
          k = [],
          l = {}; !(function (a, b) {
          for (let c = 0; c < a.length; c++) {
            l[a[c]] = {
              left: [b[c].left, b[c].centery], right: [b[c].right, b[c].centery], top: [b[c].centerx, b[c].top], bottom: [b[c].centerx, b[c].bottom]
            };
          }
        }(['source', 'target'], [c, d])); for (let m = 0; m < i.length; m++) for (let n = 0; n < i.length; n++)k.push({ source: i[m], target: i[n], dist: Biltong.lineLength(l.source[i[m]], l.target[i[n]]) }); k.sort((a, b) => (a.dist < b.dist ? -1 : a.dist > b.dist ? 1 : 0)); for (var o = k[0].source, p = k[0].target, q = 0; q < k.length && (o = !e.isContinuous || e.isEdgeSupported(k[q].source) ? k[q].source : null, p = !f.isContinuous || f.isEdgeSupported(k[q].target) ? k[q].target : null, o == null || p == null); q++);return { a: [o, p], theta: g, theta2: j };
      },
      p = function (a, b, c, d, e, f, g) {
        for (var h = [], i = b[e ? 0 : 1] / (d.length + 1), j = 0; j < d.length; j++) {
          let k = (j + 1) * i,
            l = f * b[e ? 1 : 0]; g && (k = b[e ? 0 : 1] - k); let m = e ? k : l,
            n = c[0] + m,
            o = m / b[0],
            p = e ? l : k,
            q = c[1] + p,
            r = p / b[1]; h.push([n, q, o, r, d[j][1], d[j][2]]);
        } return h;
      },
      q = function (a) { return function (b, c) { let d = !0; return d = a ? b[0][0] < c[0][0] : b[0][0] > c[0][0], d === !1 ? -1 : 1; }; },
      r = function (a, b) {
        let c = a[0][0] < 0 ? -Math.PI - a[0][0] : Math.PI - a[0][0],
          d = b[0][0] < 0 ? -Math.PI - b[0][0] : Math.PI - b[0][0]; return c > d ? 1 : -1;
      },
      s = {
        top(a, b) { return a[0] > b[0] ? 1 : -1; }, right: q(!0), bottom: q(!0), left: r
      },
      t = function (a, b) { return a.sort(b); },
      u = function (a, b) {
        let c = m.getCachedData(a),
          d = c.s,
          f = c.o,
          h = function (b, c, d, f, h, i, j) {
            if (f.length > 0) {
              for (let k = t(f, s[b]), l = b === 'right' || b === 'top', m = p(b, c, d, k, h, i, l), n = function (a, b) { e[a.id] = [b[0], b[1], b[2], b[3]], g[a.id] = j; }, o = 0; o < m.length; o++) {
                let q = m[o][4],
                  r = q.endpoints[0].elementId === a,
                  u = q.endpoints[1].elementId === a; r && n(q.endpoints[0], m[o]), u && n(q.endpoints[1], m[o]);
              }
            }
          }; h('bottom', d, [f.left, f.top], b.bottom, !0, 1, [0, 1]), h('top', d, [f.left, f.top], b.top, !0, 0, [0, -1]), h('left', d, [f.left, f.top], b.left, !1, 0, [-1, 0]), h('right', d, [f.left, f.top], b.right, !1, 1, [1, 0]);
      }; this.reset = function () { d = {}, j = {}, l = {}; }, this.addFloatingConnection = function (a, b) { n[a] = b; }, this.removeFloatingConnection = function (a) { delete n[a]; }, this.newConnection = function (a) {
      let d = a.sourceId,
        e = a.targetId,
        f = a.endpoints,
        g = !0,
        h = function (h, i, k, l, m) { d === e && k.isContinuous && (a._jsPlumb.instance.removeElement(f[1].canvas), g = !1), b.addToList(j, l, [m, i, k.constructor === c.DynamicAnchor]); }; h(0, f[0], f[0].anchor, e, a), g && h(1, f[1], f[1].anchor, d, a);
    }; const v = function (a) { !(function (a, c) { if (a) { const d = function (a) { return a[4] === c; }; b.removeWithFunction(a.top, d), b.removeWithFunction(a.left, d), b.removeWithFunction(a.bottom, d), b.removeWithFunction(a.right, d); } }(l[a.elementId], a.id)); }; this.connectionDetached = function (a, c) {
      let d = a.connection || a,
        e = a.sourceId,
        f = a.targetId,
        g = d.endpoints,
        h = function (a, c, d, e, f) { b.removeWithFunction(j[e], a => a[0].id === f.id); }; h(1, g[1], g[1].anchor, e, d), h(0, g[0], g[0].anchor, f, d), d.floatingId && (h(d.floatingIndex, d.floatingEndpoint, d.floatingEndpoint.anchor, d.floatingId, d), v(d.floatingEndpoint)), v(d.endpoints[0]), v(d.endpoints[1]), c || (k.redraw(d.sourceId), d.targetId !== d.sourceId && k.redraw(d.targetId));
    }, this.add = function (a, c) { b.addToList(d, c, a); }, this.changeId = function (a, b) { j[b] = j[a], d[b] = d[a], delete j[a], delete d[a]; }, this.getConnectionsFor = function (a) { return j[a] || []; }, this.getEndpointsFor = function (a) { return d[a] || []; }, this.deleteEndpoint = function (a) { b.removeWithFunction(d[a.elementId], b => b.id === a.id), v(a); }, this.clearFor = function (a) { delete d[a], d[a] = []; }; const w = function (c, d, e, f, g, h, i, j, k, l, m, n) {
      let o,
        p,
        q = -1,
        r = -1,
        s = f.endpoints[i],
        t = s.id,
        u = [1, 0][i],
        v = [[d, e], f, g, h, t],
        w = c[k],
        x = s._continuousAnchorEdge ? c[s._continuousAnchorEdge] : null; if (x) { const y = b.findWithFunction(x, a => a[4] === t); if (y !== -1) for (x.splice(y, 1), o = 0; o < x.length; o++)p = x[o][1], b.addWithFunction(m, p, a => a.id === p.id), b.addWithFunction(n, x[o][1].endpoints[i], a => a.id === p.endpoints[i].id), b.addWithFunction(n, x[o][1].endpoints[u], a => a.id === p.endpoints[u].id); } for (o = 0; o < w.length; o++)p = w[o][1], a.idx === 1 && w[o][3] === h && r === -1 && (r = o), b.addWithFunction(m, p, a => a.id === p.id), b.addWithFunction(n, w[o][1].endpoints[i], a => a.id === p.endpoints[i].id), b.addWithFunction(n, w[o][1].endpoints[u], a => a.id === p.endpoints[u].id); if (q !== -1)w[q] = v; else { const z = j ? r !== -1 ? r : 0 : w.length; w.splice(z, 0, v); }s._continuousAnchorEdge = k;
    }; this.updateOtherEndpoint = function (a, d, e, f) {
      let g = b.findWithFunction(j[a], a => a[0].id === f.id),
        h = b.findWithFunction(j[d], a => a[0].id === f.id); g !== -1 && (j[a][g][0] = f, j[a][g][1] = f.endpoints[1], j[a][g][2] = f.endpoints[1].anchor.constructor === c.DynamicAnchor), h > -1 && (j[d].splice(h, 1), b.addToList(j, e, [f, f.endpoints[0], f.endpoints[0].anchor.constructor === c.DynamicAnchor])), f.updateConnectedClass();
    }, this.sourceChanged = function (a, d, e, f) { if (a !== d) { e.sourceId = d, e.source = f, b.removeWithFunction(j[a], a => a[0].id === e.id); const g = b.findWithFunction(j[e.targetId], a => a[0].id === e.id); g > -1 && (j[e.targetId][g][0] = e, j[e.targetId][g][1] = e.endpoints[0], j[e.targetId][g][2] = e.endpoints[0].anchor.constructor === c.DynamicAnchor), b.addToList(j, d, [e, e.endpoints[1], e.endpoints[1].anchor.constructor === c.DynamicAnchor]), e.endpoints[1].anchor.isContinuous && (e.source === e.target ? e._jsPlumb.instance.removeElement(e.endpoints[1].canvas) : e.endpoints[1].canvas.parentNode == null && e._jsPlumb.instance.appendElement(e.endpoints[1].canvas)), e.updateConnectedClass(); } }, this.rehomeEndpoint = function (a, b, c) {
      let e = d[b] || [],
        f = m.getId(c); if (f !== b) { const g = e.indexOf(a); if (g > -1) { const h = e.splice(g, 1)[0]; k.add(h, f); } } for (let i = 0; i < a.connections.length; i++)a.connections[i].sourceId === b ? k.sourceChanged(b, a.elementId, a.connections[i], a.element) : a.connections[i].targetId === b && (a.connections[i].targetId = a.elementId, a.connections[i].target = a.element, k.updateOtherEndpoint(a.connections[i].sourceId, b, a.elementId, a.connections[i]));
    }, this.redraw = function (a, e, f, g, h, i) {
      if (!m.isSuspendDrawing()) {
        let k = d[a] || [],
          p = j[a] || [],
          q = [],
          r = [],
          s = []; f = f || m.timestamp(), g = g || { left: 0, top: 0 }, e && (e = { left: e.left + g.left, top: e.top + g.top }); for (var t = m.updateOffset({
            elId: a, offset: e, recalc: !1, timestamp: f
          }), v = {}, x = 0; x < p.length; x++) {
          var y = p[x][0],
            z = y.sourceId,
            A = y.targetId,
            B = y.endpoints[0].anchor.isContinuous,
            C = y.endpoints[1].anchor.isContinuous; if (B || C) {
            var D = `${z}_${A}`,
              E = v[D],
              F = y.sourceId === a ? 1 : 0; B && !l[z] && (l[z] = {
              top: [], right: [], bottom: [], left: []
            }), C && !l[A] && (l[A] = {
              top: [], right: [], bottom: [], left: []
            }), a !== A && m.updateOffset({ elId: A, timestamp: f }), a !== z && m.updateOffset({ elId: z, timestamp: f }); let G = m.getCachedData(A),
              H = m.getCachedData(z); A === z && (B || C) ? (w(l[z], -Math.PI / 2, 0, y, !1, A, 0, !1, 'top', z, q, r), w(l[A], -Math.PI / 2, 0, y, !1, z, 1, !1, 'top', A, q, r)) : (E || (E = o(z, A, H.o, G.o, y.endpoints[0].anchor, y.endpoints[1].anchor), v[D] = E), B && w(l[z], E.theta, 0, y, !1, A, 0, !1, E.a[0], z, q, r), C && w(l[A], E.theta2, -1, y, !0, z, 1, !0, E.a[1], A, q, r)), B && b.addWithFunction(s, z, a => a === z), C && b.addWithFunction(s, A, a => a === A), b.addWithFunction(q, y, a => a.id === y.id), (B && F === 0 || C && F === 1) && b.addWithFunction(r, y.endpoints[F], a => a.id === y.endpoints[F].id);
          }
        } for (x = 0; x < k.length; x++) {
          k[x].connections.length === 0 && k[x].anchor.isContinuous && (l[a] || (l[a] = {
            top: [], right: [], bottom: [], left: []
          }), w(l[a], -Math.PI / 2, 0, { endpoints: [k[x], k[x]], paint() {} }, !1, a, 0, !1, k[x].anchor.getDefaultFace(), a, q, r), b.addWithFunction(s, a, b => b === a));
        } for (x = 0; x < s.length; x++)u(s[x], l[s[x]]); for (x = 0; x < k.length; x++) {
          k[x].paint({
            timestamp: f, offset: t, dimensions: t.s, recalc: i !== !0
          });
        } for (x = 0; x < r.length; x++) { const I = m.getCachedData(r[x].elementId); r[x].paint({ timestamp: f, offset: I, dimensions: I.s }); } for (x = 0; x < p.length; x++) { var J = p[x][1]; if (J.anchor.constructor === c.DynamicAnchor) { J.paint({ elementWithPrecedence: a, timestamp: f }), b.addWithFunction(q, p[x][0], a => a.id === p[x][0].id); for (var K = 0; K < J.connections.length; K++)J.connections[K] !== p[x][0] && b.addWithFunction(q, J.connections[K], a => a.id === J.connections[K].id); } else J.anchor.constructor === c.Anchor && b.addWithFunction(q, p[x][0], a => a.id === p[x][0].id); } const L = n[a]; for (L && L.paint({ timestamp: f, recalc: !1, elId: a }), x = 0; x < q.length; x++) {
          q[x].paint({
            elId: a, timestamp: f, recalc: !1, clearEdits: h
          });
        }
      }
    }; const x = function (a) {
      b.EventGenerator.apply(this), this.type = 'Continuous', this.isDynamic = !0, this.isContinuous = !0; for (var c = a.faces || ['top', 'right', 'bottom', 'left'], d = !(a.clockwise === !1), h = {}, i = {
          top: 'bottom', right: 'left', left: 'right', bottom: 'top'
        }, j = {
          top: 'right', right: 'bottom', left: 'top', bottom: 'left'
        }, k = {
          top: 'left', right: 'top', left: 'bottom', bottom: 'right'
        }, l = d ? j : k, m = d ? k : j, n = a.cssClass || '', o = 0; o < c.length; o++)h[c[o]] = !0; this.getDefaultFace = function () { return c.length === 0 ? 'top' : c[0]; }, this.verifyEdge = function (a) { return h[a] ? a : h[i[a]] ? i[a] : h[l[a]] ? l[a] : h[m[a]] ? m[a] : a; }, this.isEdgeSupported = function (a) { return h[a] === !0; }, this.compute = function (a) { return f[a.element.id] || e[a.element.id] || [0, 0]; }, this.getCurrentLocation = function (a) { return f[a.element.id] || e[a.element.id] || [0, 0]; }, this.getOrientation = function (a) { return g[a.id] || [0, 0]; }, this.clearUserDefinedLocation = function () { delete f[a.elementId]; }, this.setUserDefinedLocation = function (b) { f[a.elementId] = b; }, this.getCssClass = function () { return n; };
    }; m.continuousAnchorFactory = { get(a) { return new x(a); }, clear(a) { delete f[a], delete e[a]; } };
  }, c.Anchor = function (a) {
    this.x = a.x || 0, this.y = a.y || 0, this.elementId = a.elementId, this.cssClass = a.cssClass || '', this.userDefinedLocation = null, this.orientation = a.orientation || [0, 0], this.lastReturnValue = null, this.offsets = a.offsets || [0, 0], this.timestamp = null, b.EventGenerator.apply(this), this.compute = function (a) {
      let b = a.xy,
        c = a.wh,
        d = a.timestamp; return a.clearUserDefinedLocation && (this.userDefinedLocation = null), d && d === this.timestamp ? this.lastReturnValue : (this.lastReturnValue = this.userDefinedLocation != null ? this.userDefinedLocation : [b[0] + this.x * c[0] + this.offsets[0], b[1] + this.y * c[1] + this.offsets[1]], this.timestamp = d, this.lastReturnValue);
    }, this.getCurrentLocation = function (a) { return a = a || {}, this.lastReturnValue == null || a.timestamp != null && this.timestamp !== a.timestamp ? this.compute(a) : this.lastReturnValue; };
  }, b.extend(c.Anchor, b.EventGenerator, {
    equals(a) {
      if (!a) return !1; let b = a.getOrientation(),
        c = this.getOrientation(); return this.x === a.x && this.y === a.y && this.offsets[0] === a.offsets[0] && this.offsets[1] === a.offsets[1] && c[0] === b[0] && c[1] === b[1];
    },
    getUserDefinedLocation() { return this.userDefinedLocation; },
    setUserDefinedLocation(a) { this.userDefinedLocation = a; },
    clearUserDefinedLocation() { this.userDefinedLocation = null; },
    getOrientation() { return this.orientation; },
    getCssClass() { return this.cssClass; }
  }), c.FloatingAnchor = function (a) {
    c.Anchor.apply(this, arguments); let b = a.reference,
      d = a.referenceCanvas,
      e = c.getSize(d),
      f = 0,
      g = 0,
      h = null,
      i = null; this.orientation = null, this.x = 0, this.y = 0, this.isFloating = !0, this.compute = function (a) {
      let b = a.xy,
        c = [b[0] + e[0] / 2, b[1] + e[1] / 2]; return i = c, c;
    }, this.getOrientation = function (a) { if (h) return h; const c = b.getOrientation(a); return [-1 * Math.abs(c[0]) * f, -1 * Math.abs(c[1]) * g]; }, this.over = function (a, b) { h = a.getOrientation(b); }, this.out = function () { h = null; }, this.getCurrentLocation = function (a) { return i == null ? this.compute(a) : i; };
  }, b.extend(c.FloatingAnchor, c.Anchor); const d = function (a, b, d) { return a.constructor === c.Anchor ? a : b.makeAnchor(a, d, b); }; c.DynamicAnchor = function (a) {
    c.Anchor.apply(this, arguments), this.isDynamic = !0, this.anchors = [], this.elementId = a.elementId, this.jsPlumbInstance = a.jsPlumbInstance; for (let b = 0; b < a.anchors.length; b++) this.anchors[b] = d(a.anchors[b], this.jsPlumbInstance, this.elementId); this.getAnchors = function () { return this.anchors; }, this.locked = !1; let e = this.anchors.length > 0 ? this.anchors[0] : null,
      f = e,
      g = this,
      h = function (a, b, c, d, e) {
        let f = d[0] + a.x * e[0],
          g = d[1] + a.y * e[1],
          h = d[0] + e[0] / 2,
          i = d[1] + e[1] / 2; return Math.sqrt(Math.pow(b - f, 2) + Math.pow(c - g, 2)) + Math.sqrt(Math.pow(h - f, 2) + Math.pow(i - g, 2));
      },
      i = a.selector || function (a, b, c, d, e) { for (var f = c[0] + d[0] / 2, g = c[1] + d[1] / 2, i = -1, j = 1 / 0, k = 0; k < e.length; k++) { const l = h(e[k], f, g, a, b); j > l && (i = k + 0, j = l); } return e[i]; }; this.compute = function (a) {
      let b = a.xy,
        c = a.wh,
        d = a.txy,
        h = a.twh; this.timestamp = a.timestamp; const j = g.getUserDefinedLocation(); return j != null ? j : this.locked || d == null || h == null ? e.compute(a) : (a.timestamp = null, e = i(b, c, d, h, this.anchors), this.x = e.x, this.y = e.y, e !== f && this.fire('anchorChanged', e), f = e, e.compute(a));
    }, this.getCurrentLocation = function (a) { return this.getUserDefinedLocation() || (e != null ? e.getCurrentLocation(a) : null); }, this.getOrientation = function (a) { return e != null ? e.getOrientation(a) : [0, 0]; }, this.over = function (a, b) { e != null && e.over(a, b); }, this.out = function () { e != null && e.out(); }, this.getCssClass = function () { return e && e.getCssClass() || ''; };
  }, b.extend(c.DynamicAnchor, c.Anchor); const e = function (a, b, d, e, f, g) { c.Anchors[f] = function (c) { const h = c.jsPlumbInstance.makeAnchor([a, b, d, e, 0, 0], c.elementId, c.jsPlumbInstance); return h.type = f, g && g(h, c), h; }; }; e(0.5, 0, 0, -1, 'TopCenter'), e(0.5, 1, 0, 1, 'BottomCenter'), e(0, 0.5, -1, 0, 'LeftMiddle'), e(1, 0.5, 1, 0, 'RightMiddle'), e(0.5, 0, 0, -1, 'Top'), e(0.5, 1, 0, 1, 'Bottom'), e(0, 0.5, -1, 0, 'Left'), e(1, 0.5, 1, 0, 'Right'), e(0.5, 0.5, 0, 0, 'Center'), e(1, 0, 0, -1, 'TopRight'), e(1, 1, 0, 1, 'BottomRight'), e(0, 0, 0, -1, 'TopLeft'), e(0, 1, 0, 1, 'BottomLeft'), c.Defaults.DynamicAnchors = function (a) { return a.jsPlumbInstance.makeAnchors(['TopCenter', 'RightMiddle', 'BottomCenter', 'LeftMiddle'], a.elementId, a.jsPlumbInstance); }, c.Anchors.AutoDefault = function (a) { const b = a.jsPlumbInstance.makeDynamicAnchor(c.Defaults.DynamicAnchors(a)); return b.type = 'AutoDefault', b; }; const f = function (a, b) { c.Anchors[a] = function (c) { const d = c.jsPlumbInstance.makeAnchor(['Continuous', { faces: b }], c.elementId, c.jsPlumbInstance); return d.type = a, d; }; }; c.Anchors.Continuous = function (a) { return a.jsPlumbInstance.continuousAnchorFactory.get(a); }, f('ContinuousLeft', ['left']), f('ContinuousTop', ['top']), f('ContinuousBottom', ['bottom']), f('ContinuousRight', ['right']), e(0, 0, 0, 0, 'Assign', (a, b) => { const c = b.position || 'Fixed'; a.positionFinder = c.constructor === String ? b.jsPlumbInstance.AnchorPositionFinders[c] : c, a.constructorParams = b; }), a.jsPlumbInstance.prototype.AnchorPositionFinders = {
    Fixed(a, b, c) { return [(a.left - b.left) / c[0], (a.top - b.top) / c[1]]; },
    Grid(a, b, c, d) {
      let e = a.left - b.left,
        f = a.top - b.top,
        g = c[0] / d.grid[0],
        h = c[1] / d.grid[1],
        i = Math.floor(e / g),
        j = Math.floor(f / h); return [(i * g + g / 2) / c[0], (j * h + h / 2) / c[1]];
    }
  }, c.Anchors.Perimeter = function (a) {
    a = a || {}; let b = a.anchorCount || 60,
      c = a.shape; if (!c) throw new Error('no shape supplied to Perimeter Anchor type'); let d = function () {
        for (var a = 0.5, c = 2 * Math.PI / b, d = 0, e = [], f = 0; b > f; f++) {
          let g = a + a * Math.sin(d),
            h = a + a * Math.cos(d); e.push([g, h, 0, 0]), d += c;
        } return e;
      },
      e = function (a) { for (var c = b / a.length, d = [], e = function (a, e, f, g, h) { c = b * h; for (let i = (f - a) / c, j = (g - e) / c, k = 0; c > k; k++)d.push([a + i * k, e + j * k, 0, 0]); }, f = 0; f < a.length; f++)e(...a[f]); return d; },
      f = function (a) { for (var b = [], c = 0; c < a.length; c++)b.push([a[c][0], a[c][1], a[c][2], a[c][3], 1 / a.length]); return e(b); },
      g = function () { return f([[0, 0, 1, 0], [1, 0, 1, 1], [1, 1, 0, 1], [0, 1, 0, 0]]); },
      h = {
        Circle: d, Ellipse: d, Diamond() { return f([[0.5, 0, 1, 0.5], [1, 0.5, 0.5, 1], [0.5, 1, 0, 0.5], [0, 0.5, 0.5, 0]]); }, Rectangle: g, Square: g, Triangle() { return f([[0.5, 0, 1, 1], [1, 1, 0, 1], [0, 1, 0.5, 0]]); }, Path(a) { for (var b = a.points, c = [], d = 0, f = 0; f < b.length - 1; f++) { const g = Math.sqrt(Math.pow(b[f][2] - b[f][0]) + Math.pow(b[f][3] - b[f][1])); d += g, c.push([b[f][0], b[f][1], b[f + 1][0], b[f + 1][1], g]); } for (let h = 0; h < c.length; h++)c[h][4] = c[h][4] / d; return e(c); }
      },
      i = function (a, b) {
        for (var c = [], d = b / 180 * Math.PI, e = 0; e < a.length; e++) {
          let f = a[e][0] - 0.5,
            g = a[e][1] - 0.5; c.push([0.5 + (f * Math.cos(d) - g * Math.sin(d)), 0.5 + (f * Math.sin(d) + g * Math.cos(d)), a[e][2], a[e][3]]);
        } return c;
      }; if (!h[c]) throw new Error(`Shape [${c}] is unknown by Perimeter Anchor type`); let j = h[c](a); a.rotation && (j = i(j, a.rotation)); const k = a.jsPlumbInstance.makeDynamicAnchor(j); return k.type = 'Perimeter', k;
  };
}.call(typeof window !== 'undefined' ? window : this), function () {
  let a = this,
    b = a.jsPlumb,
    c = a.jsPlumbUtil,
    d = a.Biltong; b.Segments = {
    AbstractSegment(a) {
      this.params = a, this.findClosestPointOnPath = function () {
        return {
          d: 1 / 0, x: null, y: null, l: null
        };
      }, this.getBounds = function () {
        return {
          minX: Math.min(a.x1, a.x2), minY: Math.min(a.y1, a.y2), maxX: Math.max(a.x1, a.x2), maxY: Math.max(a.y1, a.y2)
        };
      };
    },
    Straight(a) {
      let c,
        e,
        f,
        g,
        h,
        i,
        j,
        k = (b.Segments.AbstractSegment.apply(this, arguments), function () { c = Math.sqrt(Math.pow(h - g, 2) + Math.pow(j - i, 2)), e = d.gradient({ x: g, y: i }, { x: h, y: j }), f = -1 / e; }); this.type = 'Straight', this.getLength = function () { return c; }, this.getGradient = function () { return e; }, this.getCoordinates = function () {
        return {
          x1: g, y1: i, x2: h, y2: j
        };
      }, this.setCoordinates = function (a) { g = a.x1, i = a.y1, h = a.x2, j = a.y2, k(); }, this.setCoordinates({
        x1: a.x1, y1: a.y1, x2: a.x2, y2: a.y2
      }), this.getBounds = function () {
        return {
          minX: Math.min(g, h), minY: Math.min(i, j), maxX: Math.max(g, h), maxY: Math.max(i, j)
        };
      }, this.pointOnPath = function (a, b) { if (a !== 0 || b) { if (a !== 1 || b) { const e = b ? a > 0 ? a : c + a : a * c; return d.pointOnLine({ x: g, y: i }, { x: h, y: j }, e); } return { x: h, y: j }; } return { x: g, y: i }; }, this.gradientAtPoint = function () { return e; }, this.pointAlongPathFrom = function (a, b, c) {
        let e = this.pointOnPath(a, c),
          f = b <= 0 ? { x: g, y: i } : { x: h, y: j }; return b <= 0 && Math.abs(b) > 1 && (b *= -1), d.pointOnLine(e, f, b);
      }; let l = function (a, b, c) { return c >= Math.min(a, b) && c <= Math.max(a, b); },
        m = function (a, b, c) { return Math.abs(c - a) < Math.abs(c - b) ? a : b; }; this.findClosestPointOnPath = function (a, b) {
        const k = {
          d: 1 / 0, x: null, y: null, l: null, x1: g, x2: h, y1: i, y2: j
        }; if (e === 0)k.y = i, k.x = l(g, h, a) ? a : m(g, h, a); else if (1 / 0 === e || e === -1 / 0)k.x = g, k.y = l(i, j, b) ? b : m(i, j, b); else {
          let n = i - e * g,
            o = b - f * a,
            p = (o - n) / (e - f),
            q = e * p + n; k.x = l(g, h, p) ? p : m(g, h, p), k.y = l(i, j, q) ? q : m(i, j, q);
        } const r = d.lineLength([k.x, k.y], [g, i]); return k.d = d.lineLength([a, b], [k.x, k.y]), k.l = r / c, k;
      };
    },
    Arc(a) {
      var c = (b.Segments.AbstractSegment.apply(this, arguments), function (b, c) { return d.theta([a.cx, a.cy], [b, c]); }),
        e = function (a, b) {
          if (a.anticlockwise) {
            let c = a.startAngle < a.endAngle ? a.startAngle + f : a.startAngle,
              d = Math.abs(c - a.endAngle); return c - d * b;
          } let e = a.endAngle < a.startAngle ? a.endAngle + f : a.endAngle,
            g = Math.abs(e - a.startAngle); return a.startAngle + g * b;
        },
        f = 2 * Math.PI; this.radius = a.r, this.anticlockwise = a.ac, this.type = 'Arc', a.startAngle && a.endAngle ? (this.startAngle = a.startAngle, this.endAngle = a.endAngle, this.x1 = a.cx + this.radius * Math.cos(a.startAngle), this.y1 = a.cy + this.radius * Math.sin(a.startAngle), this.x2 = a.cx + this.radius * Math.cos(a.endAngle), this.y2 = a.cy + this.radius * Math.sin(a.endAngle)) : (this.startAngle = c(a.x1, a.y1), this.endAngle = c(a.x2, a.y2), this.x1 = a.x1, this.y1 = a.y1, this.x2 = a.x2, this.y2 = a.y2), this.endAngle < 0 && (this.endAngle += f), this.startAngle < 0 && (this.startAngle += f); const g = this.endAngle < this.startAngle ? this.endAngle + f : this.endAngle; this.sweep = Math.abs(g - this.startAngle), this.anticlockwise && (this.sweep = f - this.sweep); let h = 2 * Math.PI * this.radius,
        i = this.sweep / f,
        j = h * i; this.getLength = function () { return j; }, this.getBounds = function () {
        return {
          minX: a.cx - a.r, maxX: a.cx + a.r, minY: a.cy - a.r, maxY: a.cy + a.r
        };
      }; let k = 1e-10,
        l = function (a) {
          let b = Math.floor(a),
            c = Math.ceil(a); return k > a - b ? b : k > c - a ? c : a;
        }; this.pointOnPath = function (b, c) {
        if (b === 0) return { x: this.x1, y: this.y1, theta: this.startAngle }; if (b === 1) return { x: this.x2, y: this.y2, theta: this.endAngle }; c && (b /= j); let d = e(this, b),
          f = a.cx + a.r * Math.cos(d),
          g = a.cy + a.r * Math.sin(d); return { x: l(f), y: l(g), theta: d };
      }, this.gradientAtPoint = function (b, c) {
        let e = this.pointOnPath(b, c),
          f = d.normal([a.cx, a.cy], [e.x, e.y]); return this.anticlockwise || 1 / 0 !== f && f !== -1 / 0 || (f *= -1), f;
      }, this.pointAlongPathFrom = function (b, c, d) {
        let e = this.pointOnPath(b, d),
          f = 2 * (c / h) * Math.PI,
          g = this.anticlockwise ? -1 : 1,
          i = e.theta + g * f,
          j = a.cx + this.radius * Math.cos(i),
          k = a.cy + this.radius * Math.sin(i); return { x: j, y: k };
      };
    },
    Bezier(c) {
      this.curve = [{ x: c.x1, y: c.y1 }, { x: c.cp1x, y: c.cp1y }, { x: c.cp2x, y: c.cp2y }, { x: c.x2, y: c.y2 }], b.Segments.AbstractSegment.apply(this, arguments), this.bounds = {
        minX: Math.min(c.x1, c.x2, c.cp1x, c.cp2x), minY: Math.min(c.y1, c.y2, c.cp1y, c.cp2y), maxX: Math.max(c.x1, c.x2, c.cp1x, c.cp2x), maxY: Math.max(c.y1, c.y2, c.cp1y, c.cp2y)
      }, this.type = 'Bezier'; const d = function (b, c, d) { return d && (c = a.jsBezier.locationAlongCurveFrom(b, c > 0 ? 0 : 1, c)), c; }; this.pointOnPath = function (b, c) { return b = d(this.curve, b, c), a.jsBezier.pointOnCurve(this.curve, b); }, this.gradientAtPoint = function (b, c) { return b = d(this.curve, b, c), a.jsBezier.gradientAtPoint(this.curve, b); }, this.pointAlongPathFrom = function (b, c, e) { return b = d(this.curve, b, e), a.jsBezier.pointAlongCurveFrom(this.curve, b, c); }, this.getLength = function () { return a.jsBezier.getLength(this.curve); }, this.getBounds = function () { return this.bounds; };
    }
  }, b.SegmentRenderer = {
    getPath(a) {
      return {
        Straight() { const b = a.getCoordinates(); return `M ${b.x1} ${b.y1} L ${b.x2} ${b.y2}`; },
        Bezier() { const b = a.params; return `M ${b.x1} ${b.y1} C ${b.cp1x} ${b.cp1y} ${b.cp2x} ${b.cp2y} ${b.x2} ${b.y2}`; },
        Arc() {
          let b = a.params,
            c = a.sweep > Math.PI ? 1 : 0,
            d = a.anticlockwise ? 0 : 1; return `M${a.x1} ${a.y1} A ${a.radius} ${b.r} 0 ${c},${d} ${a.x2} ${a.y2}`;
        }
      }[a.type]();
    }
  }; const e = function () {
    this.resetBounds = function () {
      this.bounds = {
        minX: 1 / 0, minY: 1 / 0, maxX: -1 / 0, maxY: -1 / 0
      };
    }, this.resetBounds();
  }; b.Connectors.AbstractConnector = function (a) {
    e.apply(this, arguments); let f = [],
      g = 0,
      h = [],
      i = [],
      j = a.stub || 0,
      k = c.isArray(j) ? j[0] : j,
      l = c.isArray(j) ? j[1] : j,
      m = a.gap || 0,
      n = c.isArray(m) ? m[0] : m,
      o = c.isArray(m) ? m[1] : m,
      p = null,
      q = !1,
      r = null,
      s = null,
      t = a.editable !== !1 && b.ConnectorEditors != null && b.ConnectorEditors[this.type] != null,
      u = this.setGeometry = function (a, b) { q = !b, s = a; },
      v = this.getGeometry = function () { return s; }; this.getPathData = function () { for (var a = '', c = 0; c < f.length; c++)a += b.SegmentRenderer.getPath(f[c]), a += ' '; return a; }, this.hasBeenEdited = function () { return q; }, this.isEditing = function () { return this.editor != null && this.editor.isActive(); }, this.setEditable = function (a) { return t = a && b.ConnectorEditors != null && b.ConnectorEditors[this.type] != null && (this.overrideSetEditable == null || this.overrideSetEditable()) ? a : !1; }, this.isEditable = function () { return t; }, this.findSegmentForPoint = function (a, b) {
      for (var c = {
          d: 1 / 0, s: null, x: null, y: null, l: null
        }, d = 0; d < f.length; d++) { const e = f[d].findClosestPointOnPath(a, b); e.d < c.d && (c.d = e.d, c.l = e.l, c.x = e.x, c.y = e.y, c.s = f[d], c.x1 = e.x1, c.x2 = e.x2, c.y1 = e.y1, c.y2 = e.y2, c.index = d); } return c;
    }; let w = function () { for (let a = 0, b = 0; b < f.length; b++) { const c = f[b].getLength(); i[b] = c / g, h[b] = [a, a += c / g]; } },
      x = function (a, b) { b && (a = a > 0 ? a / g : (g + a) / g); for (var c = h.length - 1, d = 1, e = 0; e < h.length; e++) if (h[e][1] >= a) { c = e, d = a === 1 ? 1 : a === 0 ? 0 : (a - h[e][0]) / i[e]; break; } return { segment: f[c], proportion: d, index: c }; },
      y = function (a, c, d) { if (d.x1 !== d.x2 || d.y1 !== d.y2) { const e = new b.Segments[c](d); f.push(e), g += e.getLength(), a.updateBounds(e); } },
      z = function () { g = f.length = h.length = i.length = 0; }; this.setSegments = function (a) { p = [], g = 0; for (let b = 0; b < a.length; b++)p.push(a[b]), g += a[b].getLength(); }, this.getLength = function () { return g; }; const A = function (a) {
      this.strokeWidth = a.strokeWidth; let b = d.quadrant(a.sourcePos, a.targetPos),
        c = a.targetPos[0] < a.sourcePos[0],
        e = a.targetPos[1] < a.sourcePos[1],
        f = a.strokeWidth || 1,
        g = a.sourceEndpoint.anchor.getOrientation(a.sourceEndpoint),
        h = a.targetEndpoint.anchor.getOrientation(a.targetEndpoint),
        i = c ? a.targetPos[0] : a.sourcePos[0],
        j = e ? a.targetPos[1] : a.sourcePos[1],
        m = Math.abs(a.targetPos[0] - a.sourcePos[0]),
        p = Math.abs(a.targetPos[1] - a.sourcePos[1]); if (g[0] === 0 && g[1] === 0 || h[0] === 0 && h[1] === 0) {
        let q = m > p ? 0 : 1,
          r = [1, 0][q]; g = [], h = [], g[q] = a.sourcePos[q] > a.targetPos[q] ? -1 : 1, h[q] = a.sourcePos[q] > a.targetPos[q] ? 1 : -1, g[r] = 0, h[r] = 0;
      } let s = c ? m + n * g[0] : n * g[0],
        t = e ? p + n * g[1] : n * g[1],
        u = c ? o * h[0] : m + o * h[0],
        v = e ? o * h[1] : p + o * h[1],
        w = g[0] * h[0] + g[1] * h[1],
        x = {
          sx: s, sy: t, tx: u, ty: v, lw: f, xSpan: Math.abs(u - s), ySpan: Math.abs(v - t), mx: (s + u) / 2, my: (t + v) / 2, so: g, to: h, x: i, y: j, w: m, h: p, segment: b, startStubX: s + g[0] * k, startStubY: t + g[1] * k, endStubX: u + h[0] * l, endStubY: v + h[1] * l, isXGreaterThanStubTimes2: Math.abs(s - u) > k + l, isYGreaterThanStubTimes2: Math.abs(t - v) > k + l, opposite: w === -1, perpendicular: w === 0, orthogonal: w === 1, sourceAxis: g[0] === 0 ? 'y' : 'x', points: [i, j, m, p, s, t, u, v]
        }; return x.anchorOrientation = x.opposite ? 'opposite' : x.orthogonal ? 'orthogonal' : 'perpendicular', x;
    }; return this.getSegments = function () { return f; }, this.updateBounds = function (a) { const b = a.getBounds(); this.bounds.minX = Math.min(this.bounds.minX, b.minX), this.bounds.maxX = Math.max(this.bounds.maxX, b.maxX), this.bounds.minY = Math.min(this.bounds.minY, b.minY), this.bounds.maxY = Math.max(this.bounds.maxY, b.maxY); }, this.pointOnPath = function (a, b) { const c = x(a, b); return c.segment && c.segment.pointOnPath(c.proportion, !1) || [0, 0]; }, this.gradientAtPoint = function (a, b) { const c = x(a, b); return c.segment && c.segment.gradientAtPoint(c.proportion, !1) || 0; }, this.pointAlongPathFrom = function (a, b, c) { const d = x(a, c); return d.segment && d.segment.pointAlongPathFrom(d.proportion, b, !1) || [0, 0]; }, this.compute = function (a) { r = A.call(this, a), z(), this._compute(r, a), this.x = r.points[0], this.y = r.points[1], this.w = r.points[2], this.h = r.points[3], this.segment = r.segment, w(); }, {
      addSegment: y, prepareCompute: A, sourceStub: k, targetStub: l, maxStub: Math.max(k, l), sourceGap: n, targetGap: o, maxGap: Math.max(n, o), setGeometry: u, getGeometry: v
    };
  }, c.extend(b.Connectors.AbstractConnector, e), b.Endpoints.AbstractEndpoint = function (a) { e.apply(this, arguments); const b = this.compute = function () { const a = this._compute.apply(this, arguments); return this.x = a[0], this.y = a[1], this.w = a[2], this.h = a[3], this.bounds.minX = this.x, this.bounds.minY = this.y, this.bounds.maxX = this.x + this.w, this.bounds.maxY = this.y + this.h, a; }; return { compute: b, cssClass: a.cssClass }; }, c.extend(b.Endpoints.AbstractEndpoint, e), b.Endpoints.Dot = function (a) {
    this.type = 'Dot', b.Endpoints.AbstractEndpoint.apply(this, arguments), a = a || {}, this.radius = a.radius || 10, this.defaultOffset = 0.5 * this.radius, this.defaultInnerRadius = this.radius / 3, this._compute = function (a, b, c) {
      this.radius = c.radius || this.radius; let d = a[0] - this.radius,
        e = a[1] - this.radius,
        f = 2 * this.radius,
        g = 2 * this.radius; if (c.stroke) { const h = c.strokeWidth || 1; d -= h, e -= h, f += 2 * h, g += 2 * h; } return [d, e, f, g, this.radius];
    };
  }, c.extend(b.Endpoints.Dot, b.Endpoints.AbstractEndpoint), b.Endpoints.Rectangle = function (a) {
    this.type = 'Rectangle', b.Endpoints.AbstractEndpoint.apply(this, arguments), a = a || {}, this.width = a.width || 20, this.height = a.height || 20, this._compute = function (a, b, c) {
      let d = c.width || this.width,
        e = c.height || this.height,
        f = a[0] - d / 2,
        g = a[1] - e / 2; return [f, g, d, e];
    };
  }, c.extend(b.Endpoints.Rectangle, b.Endpoints.AbstractEndpoint); const f = function () { b.jsPlumbUIComponent.apply(this, arguments), this._jsPlumb.displayElements = []; }; c.extend(f, b.jsPlumbUIComponent, { getDisplayElements() { return this._jsPlumb.displayElements; }, appendDisplayElement(a) { this._jsPlumb.displayElements.push(a); } }), b.Endpoints.Image = function (d) {
    this.type = 'Image', f.apply(this, arguments), b.Endpoints.AbstractEndpoint.apply(this, arguments); let e = d.onload,
      g = d.src || d.url,
      h = d.cssClass ? ` ${d.cssClass}` : ''; this._jsPlumb.img = new Image(), this._jsPlumb.ready = !1, this._jsPlumb.initialized = !1, this._jsPlumb.deleted = !1, this._jsPlumb.widthToUse = d.width, this._jsPlumb.heightToUse = d.height, this._jsPlumb.endpoint = d.endpoint, this._jsPlumb.img.onload = function () { this._jsPlumb != null && (this._jsPlumb.ready = !0, this._jsPlumb.widthToUse = this._jsPlumb.widthToUse || this._jsPlumb.img.width, this._jsPlumb.heightToUse = this._jsPlumb.heightToUse || this._jsPlumb.img.height, e && e(this)); }.bind(this), this._jsPlumb.endpoint.setImage = function (a, b) { const c = a.constructor === String ? a : a.src; e = b, this._jsPlumb.img.src = c, this.canvas != null && this.canvas.setAttribute('src', this._jsPlumb.img.src); }.bind(this), this._jsPlumb.endpoint.setImage(g, e), this._compute = function (a) { return this.anchorPoint = a, this._jsPlumb.ready ? [a[0] - this._jsPlumb.widthToUse / 2, a[1] - this._jsPlumb.heightToUse / 2, this._jsPlumb.widthToUse, this._jsPlumb.heightToUse] : [0, 0, 0, 0]; }, this.canvas = b.createElement('img', {
      position: 'absolute', margin: 0, padding: 0, outline: 0
    }, this._jsPlumb.instance.endpointClass + h), this._jsPlumb.widthToUse && this.canvas.setAttribute('width', this._jsPlumb.widthToUse), this._jsPlumb.heightToUse && this.canvas.setAttribute('height', this._jsPlumb.heightToUse), this._jsPlumb.instance.appendElement(this.canvas), this.actuallyPaint = function () {
      if (!this._jsPlumb.deleted) {
        this._jsPlumb.initialized || (this.canvas.setAttribute('src', this._jsPlumb.img.src), this.appendDisplayElement(this.canvas), this._jsPlumb.initialized = !0); let a = this.anchorPoint[0] - this._jsPlumb.widthToUse / 2,
          b = this.anchorPoint[1] - this._jsPlumb.heightToUse / 2; c.sizeElement(this.canvas, a, b, this._jsPlumb.widthToUse, this._jsPlumb.heightToUse);
      }
    }, this.paint = function (b, c) { this._jsPlumb != null && (this._jsPlumb.ready ? this.actuallyPaint(b, c) : a.setTimeout(() => { this.paint(b, c); }, 200)); };
  }, c.extend(b.Endpoints.Image, [f, b.Endpoints.AbstractEndpoint], { cleanup(a) { a && (this._jsPlumb.deleted = !0, this.canvas && this.canvas.parentNode.removeChild(this.canvas), this.canvas = null); } }), b.Endpoints.Blank = function (a) {
    b.Endpoints.AbstractEndpoint.apply(this, arguments), this.type = 'Blank', f.apply(this, arguments), this._compute = function (a) { return [a[0], a[1], 10, 0]; }; const d = a.cssClass ? ` ${a.cssClass}` : ''; this.canvas = b.createElement('div', {
      display: 'block', width: '1px', height: '1px', background: 'transparent', position: 'absolute'
    }, this._jsPlumb.instance.endpointClass + d), this._jsPlumb.instance.appendElement(this.canvas), this.paint = function () { c.sizeElement(this.canvas, this.x, this.y, this.w, this.h); };
  }, c.extend(b.Endpoints.Blank, [b.Endpoints.AbstractEndpoint, f], { cleanup() { this.canvas && this.canvas.parentNode && this.canvas.parentNode.removeChild(this.canvas); } }), b.Endpoints.Triangle = function (a) {
    this.type = 'Triangle', b.Endpoints.AbstractEndpoint.apply(this, arguments); const c = this; a = a || {}, a.width = a.width || 55, a.height = a.height || 55, this.width = a.width, this.height = a.height, this._compute = function (a, b, d) {
      let e = d.width || c.width,
        f = d.height || c.height,
        g = a[0] - e / 2,
        h = a[1] - f / 2; return [g, h, e, f];
    };
  }; const g = b.Overlays.AbstractOverlay = function (a) { this.visible = !0, this.isAppendedAtTopLevel = !0, this.component = a.component, this.loc = a.location == null ? 0.5 : a.location, this.endpointLoc = a.endpointLocation == null ? [0.5, 0.5] : a.endpointLocation, this.visible = a.visible !== !1; }; g.prototype = {
    cleanup(a) { a && (this.component = null, this.canvas = null, this.endpointLoc = null); }, reattach() {}, setVisible(a) { this.visible = a, this.component.repaint(); }, isVisible() { return this.visible; }, hide() { this.setVisible(!1); }, show() { this.setVisible(!0); }, incrementLocation(a) { this.loc += a, this.component.repaint(); }, setLocation(a) { this.loc = a, this.component.repaint(); }, getLocation() { return this.loc; }, updateFrom() {}
  }, b.Overlays.Arrow = function (a) {
    this.type = 'Arrow', g.apply(this, arguments), this.isAppendedAtTopLevel = !1, a = a || {}; const e = this; this.length = a.length || 20, this.width = a.width || 20, this.id = a.id; let f = (a.direction || 1) < 0 ? -1 : 1,
      h = a.paintStyle || { 'stroke-width': 1 },
      i = a.foldback || 0.623; this.computeMaxSize = function () { return 1.5 * e.width; }, this.elementCreated = function (c) { if (this.path = c, a.events) for (const d in a.events)b.on(c, d, a.events[d]); }, this.draw = function (a, b) {
      let e,
        g,
        j,
        k,
        l; if (a.pointAlongPathFrom) {
        if (c.isString(this.loc) || this.loc > 1 || this.loc < 0) {
          let m = parseInt(this.loc, 10),
            n = this.loc < 0 ? 1 : 0; e = a.pointAlongPathFrom(n, m, !1), g = a.pointAlongPathFrom(n, m - f * this.length / 2, !1), j = d.pointOnLine(e, g, this.length);
        } else if (this.loc === 1) { if (e = a.pointOnPath(this.loc), g = a.pointAlongPathFrom(this.loc, -this.length), j = d.pointOnLine(e, g, this.length), f === -1) { const o = j; j = e, e = o; } } else if (this.loc === 0) { if (j = a.pointOnPath(this.loc), g = a.pointAlongPathFrom(this.loc, this.length), e = d.pointOnLine(j, g, this.length), f === -1) { const p = j; j = e, e = p; } } else e = a.pointAlongPathFrom(this.loc, f * this.length / 2), g = a.pointOnPath(this.loc), j = d.pointOnLine(e, g, this.length); k = d.perpendicularLineTo(e, j, this.width), l = d.pointOnLine(e, j, i * this.length); let q = { hxy: e, tail: k, cxy: l },
          r = h.stroke || b.stroke,
          s = h.fill || b.stroke,
          t = h.strokeWidth || b.strokeWidth; return {
          component: a, d: q, 'stroke-width': t, stroke: r, fill: s, minX: Math.min(e.x, k[0].x, k[1].x), maxX: Math.max(e.x, k[0].x, k[1].x), minY: Math.min(e.y, k[0].y, k[1].y), maxY: Math.max(e.y, k[0].y, k[1].y)
        };
      } return {
        component: a, minX: 0, maxX: 0, minY: 0, maxY: 0
      };
    };
  }, c.extend(b.Overlays.Arrow, g, { updateFrom(a) { this.length = a.length || this.length, this.width = a.width || this.width, this.direction = a.direction != null ? a.direction : this.direction, this.foldback = a.foldback || this.foldback; } }), b.Overlays.PlainArrow = function (a) { a = a || {}; const c = b.extend(a, { foldback: 1 }); b.Overlays.Arrow.call(this, c), this.type = 'PlainArrow'; }, c.extend(b.Overlays.PlainArrow, b.Overlays.Arrow), b.Overlays.Diamond = function (a) {
    a = a || {}; let c = a.length || 40,
      d = b.extend(a, { length: c / 2, foldback: 2 }); b.Overlays.Arrow.call(this, d), this.type = 'Diamond';
  }, c.extend(b.Overlays.Diamond, b.Overlays.Arrow); let h = function (a, b) { return (a._jsPlumb.cachedDimensions == null || b) && (a._jsPlumb.cachedDimensions = a.getDimensions()), a._jsPlumb.cachedDimensions; },
    i = function (a) {
      b.jsPlumbUIComponent.apply(this, arguments), g.apply(this, arguments); const d = this.fire; this.fire = function () { d.apply(this, arguments), this.component && this.component.fire.apply(this.component, arguments); }, this.detached = !1, this.id = a.id, this._jsPlumb.div = null, this._jsPlumb.initialised = !1, this._jsPlumb.component = a.component, this._jsPlumb.cachedDimensions = null, this._jsPlumb.create = a.create, this._jsPlumb.initiallyInvisible = a.visible === !1, this.getElement = function () {
        if (this._jsPlumb.div == null) {
          const c = this._jsPlumb.div = b.getElement(this._jsPlumb.create(this._jsPlumb.component));
          c.style.position = 'absolute', c.className = `${this._jsPlumb.instance.overlayClass} ${this.cssClass ? this.cssClass : a.cssClass ? a.cssClass : ''}`, this._jsPlumb.instance.appendElement(c), this._jsPlumb.instance.getId(c), this.canvas = c; const d = 'translate(-50%, -50%)'; c.style.webkitTransform = d, c.style.mozTransform = d, c.style.msTransform = d, c.style.oTransform = d, c.style.transform = d, c._jsPlumb = this, a.visible === !1 && (c.style.display = 'none');
        } return this._jsPlumb.div;
      }, this.draw = function (a, b, d) {
        const e = h(this); if (e != null && e.length === 2) {
          let f = { x: 0, y: 0 }; if (d)f = { x: d[0], y: d[1] }; else if (a.pointOnPath) {
            let g = this.loc,
              i = !1; (c.isString(this.loc) || this.loc < 0 || this.loc > 1) && (g = parseInt(this.loc, 10), i = !0), f = a.pointOnPath(g, i);
          } else { const j = this.loc.constructor === Array ? this.loc : this.endpointLoc; f = { x: j[0] * a.w, y: j[1] * a.h }; } let k = f.x - e[0] / 2,
            l = f.y - e[1] / 2; return {
            component: a,
            d: {
              minx: k, miny: l, td: e, cxy: f
            },
            minX: k,
            maxX: k + e[0],
            minY: l,
            maxY: l + e[1]
          };
        } return {
          minX: 0, maxX: 0, minY: 0, maxY: 0
        };
      };
    }; c.extend(i, [b.jsPlumbUIComponent, g], {
    getDimensions() { return [1, 1]; }, setVisible(a) { this._jsPlumb.div && (this._jsPlumb.div.style.display = a ? 'block' : 'none', a && this._jsPlumb.initiallyInvisible && (h(this, !0), this.component.repaint(), this._jsPlumb.initiallyInvisible = !1)); }, clearCachedDimensions() { this._jsPlumb.cachedDimensions = null; }, cleanup(a) { a ? this._jsPlumb.div != null && (this._jsPlumb.div._jsPlumb = null, this._jsPlumb.instance.removeElement(this._jsPlumb.div)) : (this._jsPlumb && this._jsPlumb.div && this._jsPlumb.div.parentNode && this._jsPlumb.div.parentNode.removeChild(this._jsPlumb.div), this.detached = !0); }, reattach(a) { this._jsPlumb.div != null && a.getContainer().appendChild(this._jsPlumb.div), this.detached = !1; }, computeMaxSize() { const a = h(this); return Math.max(a[0], a[1]); }, paint(a) { this._jsPlumb.initialised || (this.getElement(), a.component.appendDisplayElement(this._jsPlumb.div), this._jsPlumb.initialised = !0, this.detached && this._jsPlumb.div.parentNode.removeChild(this._jsPlumb.div)), this._jsPlumb.div.style.left = `${a.component.x + a.d.minx}px`, this._jsPlumb.div.style.top = `${a.component.y + a.d.miny}px`; }
  }), b.Overlays.Custom = function () { this.type = 'Custom', i.apply(this, arguments); }, c.extend(b.Overlays.Custom, i), b.Overlays.GuideLines = function () {
    const a = this; a.length = 50, a.strokeWidth = 5, this.type = 'GuideLines', g.apply(this, arguments), b.jsPlumbUIComponent.apply(this, arguments), this.draw = function (b) {
      let c = b.pointAlongPathFrom(a.loc, a.length / 2),
        e = b.pointOnPath(a.loc),
        f = d.pointOnLine(c, e, a.length),
        g = d.perpendicularLineTo(c, f, 40),
        h = d.perpendicularLineTo(f, c, 20); return {
        connector: b, head: c, tail: f, headLine: h, tailLine: g, minX: Math.min(c.x, f.x, h[0].x, h[1].x), minY: Math.min(c.y, f.y, h[0].y, h[1].y), maxX: Math.max(c.x, f.x, h[0].x, h[1].x), maxY: Math.max(c.y, f.y, h[0].y, h[1].y)
      };
    };
  }, b.Overlays.Label = function (a) { this.labelStyle = a.labelStyle, this.cssClass = this.labelStyle != null ? this.labelStyle.cssClass : null; const c = b.extend({ create() { return b.createElement('div'); } }, a); if (b.Overlays.Custom.call(this, c), this.type = 'Label', this.label = a.label || '', this.labelText = null, this.labelStyle) { const d = this.getElement(); if (this.labelStyle.font = this.labelStyle.font || '12px sans-serif', d.style.font = this.labelStyle.font, d.style.color = this.labelStyle.color || 'black', this.labelStyle.fill && (d.style.background = this.labelStyle.fill), this.labelStyle.borderWidth > 0) { const e = this.labelStyle.borderStyle ? this.labelStyle.borderStyle : 'black'; d.style.border = `${this.labelStyle.borderWidth}px solid ${e}`; } this.labelStyle.padding && (d.style.padding = this.labelStyle.padding); } }, c.extend(b.Overlays.Label, b.Overlays.Custom, {
    cleanup(a) { a && (this.div = null, this.label = null, this.labelText = null, this.cssClass = null, this.labelStyle = null); }, getLabel() { return this.label; }, setLabel(a) { this.label = a, this.labelText = null, this.clearCachedDimensions(), this.update(), this.component.repaint(); }, getDimensions() { return this.update(), i.prototype.getDimensions.apply(this, arguments); }, update() { if (typeof this.label === 'function') { const a = this.label(this); this.getElement().innerHTML = a.replace(/\r\n/g, '<br/>'); } else this.labelText == null && (this.labelText = this.label, this.getElement().innerHTML = this.labelText.replace(/\r\n/g, '<br/>')); }, updateFrom(a) { a.label != null && this.setLabel(a.label); }
  });
}.call(typeof window !== 'undefined' ? window : this), function () {
  let a = this,
    b = a.jsPlumb,
    c = function (b) { let c = b._mottle; return c || (c = b._mottle = new a.Mottle()), c; }; b.extend(a.jsPlumbInstance.prototype, { getEventManager() { return c(this); }, on() { return this.getEventManager().on.apply(this, arguments), this; }, off() { return this.getEventManager().off.apply(this, arguments), this; } });
}.call(typeof window !== 'undefined' ? window : this), function () {
  let a = this,
    b = a.jsPlumbUtil,
    c = a.jsPlumbInstance,
    d = 'jtk-group-collapsed',
    e = 'jtk-group-expanded',
    f = '[jtk-group-content]',
    g = 'elementDraggable',
    h = 'stop',
    i = 'revert',
    j = '_groupManager',
    k = '_jsPlumbGroup',
    l = '_jsPlumbGroupDrag',
    m = 'group:addMember',
    n = 'group:removeMember',
    o = 'group:add',
    p = 'group:remove',
    q = 'group:expand',
    r = 'group:collapse',
    s = 'groupDragStop',
    t = 'connectionMoved',
    u = 'internal.connectionDetached',
    v = 'removeAll',
    w = 'orphanAll',
    x = 'show',
    y = 'hide',
    z = function (a) {
      function c(a) {
        delete a.proxies; let c,
          d = i[a.id]; d != null && (c = function (b) { return b.id === a.id; }, b.removeWithFunction(d.connections.source, c), b.removeWithFunction(d.connections.target, c), delete i[a.id]), d = j[a.id], d != null && (c = function (b) { return b.id === a.id; }, b.removeWithFunction(d.connections.source, c), b.removeWithFunction(d.connections.target, c), delete j[a.id]);
      } function f(b, c) { for (let d = b.getMembers(), e = 0; e < d.length; e++)a[c ? x : y](d[e], !0); } function g(b) {
        let c = b.getMembers(),
          d = a.getConnections({ source: c }, !0),
          e = a.getConnections({ target: c }, !0),
          f = {}; b.connections.source.length = 0, b.connections.target.length = 0; const g = function (a) { for (let c = 0; c < a.length; c++)f[a[c].id] || (f[a[c].id] = !0, a[c].source._jsPlumbGroup === b ? (a[c].target._jsPlumbGroup !== b && b.connections.source.push(a[c]), i[a[c].id] = b) : a[c].target._jsPlumbGroup === b && (b.connections.target.push(a[c]), j[a[c].id] = b)); }; g(d), g(e);
      } var h = {},
        i = {},
        j = {},
        l = this; a.bind('connection', (a) => { a.source[k] != null && a.target[k] != null && a.source[k] === a.target[k] ? (i[a.connection.id] = a.source[k], j[a.connection.id] = a.source[k]) : (a.source[k] != null && (b.suggest(a.source[k].connections.source, a.connection), i[a.connection.id] = a.source[k]), a.target[k] != null && (b.suggest(a.target[k].connections.target, a.connection), j[a.connection.id] = a.target[k])); }), a.bind(u, (a) => { c(a.connection); }), a.bind(t, (a) => {
        let b = a.index === 0 ? i : j,
          c = b[a.connection.id]; if (c) {
          let d = c.connections[a.index === 0 ? 'source' : 'target'],
            e = d.indexOf(a.connection); e !== -1 && d.splice(e, 1);
        }
      }), this.addGroup = function (b) { a.addClass(b.getEl(), e), h[b.id] = b, b.manager = this, g(b), a.fire(o, { group: b }); }, this.addToGroup = function (b, c, d) {
        if (b = this.getGroup(b)) {
          const e = b.getEl(); if (c._isJsPlumbGroup) return; const f = c._jsPlumbGroup; if (f !== b) {
            let g = a.getOffset(c, !0),
              h = b.collapsed ? a.getOffset(e, !0) : a.getOffset(b.getDragArea(), !0); f != null && (f.remove(c, d), l.updateConnectionsForGroup(f)), b.add(c, d); const i = function (a, c) { const d = c === 0 ? 1 : 0; a.each((a) => { a.setVisible(!1), a.endpoints[d].element._jsPlumbGroup === b ? (a.endpoints[d].setVisible(!1), l.expandConnection(a, d, b)) : (a.endpoints[c].setVisible(!1), l.collapseConnection(a, c, b)); }); }; b.collapsed && (i(a.select({ source: c }), 0), i(a.select({ target: c }), 1)); const j = a.getId(c); a.dragManager.setParent(c, j, e, a.getId(e), g); const k = { left: g.left - h.left, top: g.top - h.top }; a.setPosition(c, k), a.dragManager.revalidateParent(c, j, g), l.updateConnectionsForGroup(b), a.revalidate(j), setTimeout(() => { a.fire(m, { group: b, el: c }); }, 0);
          }
        }
      }, this.removeFromGroup = function (a, b, c) { a = this.getGroup(a), a && a.remove(b, null, c); }, this.getGroup = function (a) { let c = a; if (b.isString(a) && (c = h[a], c == null)) throw new TypeError(`No such group [${a}]`); return c; }, this.getGroups = function () { const a = []; for (const b in h)a.push(h[b]); return a; }, this.removeGroup = function (b, c, d, e) { b = this.getGroup(b), this.expandGroup(b, !0), b[c ? v : w](d, e), a.remove(b.getEl()), delete h[b.id], delete a._groups[b.id], a.fire(p, { group: b }); }, this.removeAllGroups = function (a, b, c) { for (const d in h) this.removeGroup(h[d], a, b, c); }; const n = this.collapseConnection = function (b, c, d) {
        let e,
          f = d.getEl(),
          g = a.getId(f),
          h = b.endpoints[c].elementId,
          i = b.endpoints[c === 0 ? 1 : 0].element; i[k] && !i[k].shouldProxy() && i[k].collapsed || (b.proxies = b.proxies || [], e = b.proxies[c] ? b.proxies[c].ep : a.addEndpoint(f, { endpoint: d.getEndpoint(b, c), anchor: d.getAnchor(b, c), parameters: { isProxyEndpoint: !0 } }), e.setDeleteOnEmpty(!0), b.proxies[c] = { ep: e, originalEp: b.endpoints[c] }, c === 0 ? a.anchorManager.sourceChanged(h, g, b, f) : (a.anchorManager.updateOtherEndpoint(b.endpoints[0].elementId, h, g, b), b.target = f, b.targetId = g), b.proxies[c].originalEp.detachFromConnection(b, null, !0), e.connections = [b], b.endpoints[c] = e, b.setVisible(!0));
      }; this.collapseGroup = function (b) { if (b = this.getGroup(b), b != null && !b.collapsed) { const c = b.getEl(); if (f(b, !1), b.shouldProxy()) { const g = function (a, c) { for (let d = 0; d < a.length; d++) { const e = a[d]; n(e, c, b); } }; g(b.connections.source, 0), g(b.connections.target, 1); }b.collapsed = !0, a.removeClass(c, e), a.addClass(c, d), a.revalidate(c), a.fire(r, { group: b }); } }; const s = this.expandConnection = function (b, c, d) {
        if (b.proxies != null && b.proxies[c] != null) {
          let e = a.getId(d.getEl()),
            f = b.proxies[c].originalEp.element,
            g = b.proxies[c].originalEp.elementId; b.endpoints[c] = b.proxies[c].originalEp, c === 0 ? a.anchorManager.sourceChanged(e, g, b, f) : (a.anchorManager.updateOtherEndpoint(b.endpoints[0].elementId, e, g, b), b.target = f, b.targetId = g), b.proxies[c].ep.detachFromConnection(b, null), b.proxies[c].originalEp.addConnection(b), delete b.proxies[c];
        }
      }; this.expandGroup = function (b, c) { if (b = this.getGroup(b), b != null && b.collapsed) { const g = b.getEl(); if (f(b, !0), b.shouldProxy()) { const h = function (a, c) { for (let d = 0; d < a.length; d++) { const e = a[d]; s(e, c, b); } }; h(b.connections.source, 0), h(b.connections.target, 1); }b.collapsed = !1, a.addClass(g, e), a.removeClass(g, d), a.revalidate(g), this.repaintGroup(b), c || a.fire(q, { group: b }); } }, this.repaintGroup = function (b) { b = this.getGroup(b); for (let c = b.getMembers(), d = 0; d < c.length; d++)a.revalidate(c[d]); }, this.updateConnectionsForGroup = g, this.refreshAllGroups = function () { for (const b in h)g(h[b]), a.dragManager.updateOffsets(a.getId(h[b].getEl())); };
    },
    A = function (c, d) {
      function e(a) { return a.offsetParent; } function j(a, b) {
        let d = e(a),
          f = c.getSize(d),
          g = c.getSize(a),
          h = b[0],
          i = h + g[0],
          j = b[1],
          k = j + g[1]; return i > 0 && h < f[0] && k > 0 && j < f[1];
      } function o(a) {
        let b = c.getId(a),
          d = c.getOffset(a); a.parentNode.removeChild(a), c.getContainer().appendChild(a), c.setPosition(a, d), delete a._jsPlumbGroup, r(a), c.dragManager.clearParent(a, b);
      } function p(a) { if (!j(a.el, a.pos)) { const b = a.el._jsPlumbGroup; B ? c.remove(a.el) : o(a.el), b.remove(a.el); } } function q(a) { const b = c.getId(a); c.revalidate(a), c.dragManager.revalidateParent(a, b); } function r(a) { a._katavorioDrag && ((B || A) && a._katavorioDrag.off(h, p), B || A || !z || (a._katavorioDrag.off(i, q), a._katavorioDrag.setRevert(null))); } function t(a) { a._katavorioDrag && ((B || A) && a._katavorioDrag.on(h, p), y && a._katavorioDrag.setConstrain(!0), x && a._katavorioDrag.setUseGhostProxy(!0), B || A || !z || (a._katavorioDrag.on(i, q), a._katavorioDrag.setRevert((a, b) => !j(a, b)))); } let u = this,
        v = d.el; this.getEl = function () { return v; }, this.id = d.id || b.uuid(), v._isJsPlumbGroup = !0; var w = this.getDragArea = function () { const a = c.getSelector(v, f); return a && a.length > 0 ? a[0] : v; },
        x = d.ghost === !0,
        y = x || d.constrain === !0,
        z = d.revert !== !1,
        A = d.orphan === !0,
        B = d.prune === !0,
        C = d.dropOverride === !0,
        D = d.proxied !== !1,
        E = []; if (this.connections = { source: [], target: [], internal: [] }, this.getAnchor = function () { return d.anchor || 'Continuous'; }, this.getEndpoint = function () { return d.endpoint || ['Dot', { radius: 10 }]; }, this.collapsed = !1, d.draggable !== !1) { const F = { stop(a) { c.fire(s, jsPlumb.extend(a, { group: u })); }, scope: l }; d.dragOptions && a.jsPlumb.extend(F, d.dragOptions), c.draggable(d.el, F); }d.droppable !== !1 && c.droppable(d.el, { drop(a) { const b = a.drag.el; if (!b._isJsPlumbGroup) { const d = b._jsPlumbGroup; if (d !== u) { if (d != null && d.overrideDrop(b, u)) return; c.getGroupManager().addToGroup(u, b, !1); } } } }); const G = function (a, b) { for (let c = a.nodeType == null ? a : [a], d = 0; d < c.length; d++)b(c[d]); }; this.overrideDrop = function () { return C && (z || B || A); }, this.add = function (a, b) { const d = w(); G(a, (a) => { if (a._jsPlumbGroup != null) { if (a._jsPlumbGroup === u) return; a._jsPlumbGroup.remove(a, !0, b, !1); }a._jsPlumbGroup = u, E.push(a), c.isAlreadyDraggable(a) && t(a), a.parentNode !== d && d.appendChild(a), b || c.fire(m, { group: u, el: a }); }), c.getGroupManager().updateConnectionsForGroup(u); }, this.remove = function (a, d, e, f) { G(a, (a) => { if (delete a._jsPlumbGroup, b.removeWithFunction(E, b => b === a), d) try { u.getDragArea().removeChild(a); } catch (f) { jsPlumbUtil.log(`Could not remove element from Group ${f}`); }r(a), e || c.fire(n, { group: u, el: a }); }), f || c.getGroupManager().updateConnectionsForGroup(u); }, this.removeAll = function (a, b) { for (let d = 0, e = E.length; e > d; d++)u.remove(E[0], a, b, !0); E.length = 0, c.getGroupManager().updateConnectionsForGroup(u); }, this.orphanAll = function () { for (let a = 0; a < E.length; a++)o(E[a]); E.length = 0; }, this.getMembers = function () { return E; }, v[k] = this, c.bind(g, (a) => { a.el._jsPlumbGroup === this && t(a.el); }), this.shouldProxy = function () { return D; }, c.getGroupManager().addGroup(this);
    }; c.prototype.addGroup = function (a) { const b = this; if (b._groups = b._groups || {}, b._groups[a.id] != null) throw new TypeError(`cannot create Group [${a.id}]; a Group with that ID exists`); if (a.el[k] != null) throw new TypeError(`cannot create Group [${a.id}]; the given element is already a Group`); const c = new A(b, a); return b._groups[c.id] = c, a.collapsed && this.collapseGroup(c), c; }, c.prototype.addToGroup = function (a, b, c) { const d = function (b) { const d = this.getId(b); this.manage(d, b), this.getGroupManager().addToGroup(a, b, c); }.bind(this); if (Array.isArray(b)) for (let e = 0; e < b.length; e++)d(b[e]); else d(b); }, c.prototype.removeFromGroup = function (a, b, c) { this.getGroupManager().removeFromGroup(a, b, c); }, c.prototype.removeGroup = function (a, b, c, d) { this.getGroupManager().removeGroup(a, b, c, d); }, c.prototype.removeAllGroups = function (a, b, c) { this.getGroupManager().removeAllGroups(a, b, c); }, c.prototype.getGroup = function (a) { return this.getGroupManager().getGroup(a); }, c.prototype.getGroups = function () { return this.getGroupManager().getGroups(); }, c.prototype.expandGroup = function (a) { this.getGroupManager().expandGroup(a); }, c.prototype.collapseGroup = function (a) { this.getGroupManager().collapseGroup(a); }, c.prototype.repaintGroup = function (a) { this.getGroupManager().repaintGroup(a); }, c.prototype.toggleGroup = function (a) { a = this.getGroupManager().getGroup(a), a != null && this.getGroupManager()[a.collapsed ? 'expandGroup' : 'collapseGroup'](a); }, c.prototype.getGroupManager = function () { let a = this[j]; return a == null && (a = this[j] = new z(this)), a; }, c.prototype.removeGroupManager = function () { delete this[j]; }, c.prototype.getGroupFor = function (a) { return a = this.getElement(a), a ? a[k] : void 0; };
}.call(typeof window !== 'undefined' ? window : this), function () {
  let a = this,
    b = a.jsPlumb,
    c = a.jsPlumbUtil,
    d = function (a) {
      this.type = 'Flowchart', a = a || {}, a.stub = a.stub == null ? 30 : a.stub; let c,
        d,
        e = b.Connectors.AbstractConnector.apply(this, arguments),
        f = a.midpoint == null ? 0.5 : a.midpoint,
        g = a.alwaysRespectStubs === !0,
        h = null,
        i = null,
        j = a.cornerRadius != null ? a.cornerRadius : 0,
        k = (a.loopbackRadius || 25, function (a) { return a < 0 ? -1 : a === 0 ? 0 : 1; }),
        l = function (a, b, c, d) {
          if (h !== b || i !== c) {
            let e = h == null ? d.sx : h,
              f = i == null ? d.sy : i,
              g = e === b ? 'v' : 'h',
              j = k(b - e),
              l = k(c - f); h = b, i = c, a.push([e, f, b, c, g, j, l]);
          }
        },
        m = function (a) { return Math.sqrt(Math.pow(a[0] - a[2], 2) + Math.pow(a[1] - a[3], 2)); },
        n = function (a) { const b = []; return b.push(...a), b; },
        o = function (a, b, c) {
          for (var d, f = null, g = 0; g < b.length - 1; g++) {
            if (f = f || n(b[g]), d = n(b[g + 1]), j > 0 && f[4] !== d[4]) {
              const h = Math.min(j, m(f), m(d)); f[2] -= f[5] * h, f[3] -= f[6] * h, d[0] += d[5] * h, d[1] += d[6] * h; let i = f[6] === d[5] && d[5] === 1 || f[6] === d[5] && d[5] === 0 && f[5] !== d[6] || f[6] === d[5] && d[5] === -1,
                k = d[1] > f[3] ? 1 : -1,
                l = d[0] > f[2] ? 1 : -1,
                o = k === l,
                p = o && i || !o && !i ? d[0] : f[2],
                q = o && i || !o && !i ? f[3] : d[1]; e.addSegment(a, 'Straight', {
                x1: f[0], y1: f[1], x2: f[2], y2: f[3]
              }), e.addSegment(a, 'Arc', {
                r: h, x1: f[2], y1: f[3], x2: d[0], y2: d[1], cx: p, cy: q, ac: i
              });
            } else {
              let r = f[2] === f[0] ? 0 : f[2] > f[0] ? c.lw / 2 : -(c.lw / 2),
                s = f[3] === f[1] ? 0 : f[3] > f[1] ? c.lw / 2 : -(c.lw / 2); e.addSegment(a, 'Straight', {
                x1: f[0] - r, y1: f[1] - s, x2: f[2] + r, y2: f[3] + s
              });
            }f = d;
          }d != null && e.addSegment(a, 'Straight', {
            x1: d[0], y1: d[1], x2: d[2], y2: d[3]
          });
        }; this._compute = function (a, b) {
        c = [], h = null, i = null, d = null; let j = function () { return [a.startStubX, a.startStubY, a.endStubX, a.endStubY]; },
          k = {
            perpendicular: j,
            orthogonal: j,
            opposite(b) {
              let c = a,
                d = b === 'x' ? 0 : 1,
                e = { x() { return c.so[d] === 1 && (c.startStubX > c.endStubX && c.tx > c.startStubX || c.sx > c.endStubX && c.tx > c.sx) || c.so[d] === -1 && (c.startStubX < c.endStubX && c.tx < c.startStubX || c.sx < c.endStubX && c.tx < c.sx); }, y() { return c.so[d] === 1 && (c.startStubY > c.endStubY && c.ty > c.startStubY || c.sy > c.endStubY && c.ty > c.sy) || c.so[d] === -1 && (c.startStubY < c.endStubY && c.ty < c.startStubY || c.sy < c.endStubY && c.ty < c.sy); } }; return !g && e[b]() ? { x: [(a.sx + a.tx) / 2, a.startStubY, (a.sx + a.tx) / 2, a.endStubY], y: [a.startStubX, (a.sy + a.ty) / 2, a.endStubX, (a.sy + a.ty) / 2] }[b] : [a.startStubX, a.startStubY, a.endStubX, a.endStubY];
            }
          },
          m = k[a.anchorOrientation](a.sourceAxis),
          n = a.sourceAxis === 'x' ? 0 : 1,
          p = a.sourceAxis === 'x' ? 1 : 0,
          q = m[n],
          r = m[p],
          s = m[n + 2],
          t = m[p + 2]; l(c, m[0], m[1], a); let u = a.startStubX + (a.endStubX - a.startStubX) * f,
          v = a.startStubY + (a.endStubY - a.startStubY) * f,
          w = { x: [0, 1], y: [1, 0] },
          x = {
            perpendicular(b) {
              let c = a,
                d = { x: [[[1, 2, 3, 4], null, [2, 1, 4, 3]], null, [[4, 3, 2, 1], null, [3, 4, 1, 2]]], y: [[[3, 2, 1, 4], null, [2, 3, 4, 1]], null, [[4, 1, 2, 3], null, [1, 4, 3, 2]]] },
                e = { x: [[c.startStubX, c.endStubX], null, [c.endStubX, c.startStubX]], y: [[c.startStubY, c.endStubY], null, [c.endStubY, c.startStubY]] },
                f = { x: [[u, c.startStubY], [u, c.endStubY]], y: [[c.startStubX, v], [c.endStubX, v]] },
                g = { x: [[c.endStubX, c.startStubY]], y: [[c.startStubX, c.endStubY]] },
                h = { x: [[c.startStubX, c.endStubY], [c.endStubX, c.endStubY]], y: [[c.endStubX, c.startStubY], [c.endStubX, c.endStubY]] },
                i = { x: [[c.startStubX, v], [c.endStubX, v], [c.endStubX, c.endStubY]], y: [[u, c.startStubY], [u, c.endStubY], [c.endStubX, c.endStubY]] },
                j = { x: [c.startStubY, c.endStubY], y: [c.startStubX, c.endStubX] },
                k = w[b][0],
                l = w[b][1],
                m = c.so[k] + 1,
                n = c.to[l] + 1,
                o = c.to[l] === -1 && j[b][1] < j[b][0] || c.to[l] === 1 && j[b][1] > j[b][0],
                p = e[b][m][0],
                q = e[b][m][1],
                r = d[b][m][n]; return c.segment === r[3] || c.segment === r[2] && o ? f[b] : c.segment === r[2] && p > q ? g[b] : c.segment === r[2] && q >= p || c.segment === r[1] && !o ? i[b] : c.segment === r[0] || c.segment === r[1] && o ? h[b] : void 0;
            },
            orthogonal(b, c, d, e, f) {
              let g = a,
                h = { x: g.so[0] === -1 ? Math.min(c, e) : Math.max(c, e), y: g.so[1] === -1 ? Math.min(c, e) : Math.max(c, e) }[b]; return { x: [[h, d], [h, f], [e, f]], y: [[d, h], [f, h], [f, e]] }[b];
            },
            opposite(c, d, f, g) {
              let h = a,
                i = { x: 'y', y: 'x' }[c],
                j = { x: 'height', y: 'width' }[c],
                k = h[`is${c.toUpperCase()}GreaterThanStubTimes2`]; if (b.sourceEndpoint.elementId === b.targetEndpoint.elementId) { const l = f + (1 - b.sourceEndpoint.anchor[i]) * b.sourceInfo[j] + e.maxStub; return { x: [[d, l], [g, l]], y: [[l, d], [l, g]] }[c]; } return !k || h.so[n] === 1 && d > g || h.so[n] === -1 && g > d ? { x: [[d, v], [g, v]], y: [[u, d], [u, g]] }[c] : h.so[n] === 1 && g > d || h.so[n] === -1 && d > g ? { x: [[u, h.sy], [u, h.ty]], y: [[h.sx, v], [h.tx, v]] }[c] : void 0;
            }
          },
          y = x[a.anchorOrientation](a.sourceAxis, q, r, s, t); if (y) for (let z = 0; z < y.length; z++)l(c, y[z][0], y[z][1], a); l(c, m[2], m[3], a), l(c, a.tx, a.ty, a), o(this, c, a);
      };
    }; c.extend(d, b.Connectors.AbstractConnector), b.registerConnectorType(d, 'Flowchart');
}.call(typeof window !== 'undefined' ? window : this), function () {
  let a = this,
    b = a.jsPlumb,
    c = a.jsPlumbUtil; b.Connectors.AbstractBezierConnector = function (a) {
    a = a || {}; let c,
      d = a.showLoopback !== !1,
      e = (a.curviness || 10, a.margin || 5),
      f = (a.proximityLimit || 80, a.orientation && a.orientation === 'clockwise'),
      g = a.loopbackRadius || 25,
      h = !1; return this.overrideSetEditable = function () { return !h; }, this._compute = function (a, b) {
      let i = b.sourcePos,
        j = b.targetPos,
        k = Math.abs(i[0] - j[0]),
        l = Math.abs(i[1] - j[1]); if (d && b.sourceEndpoint.elementId === b.targetEndpoint.elementId) {
        h = !0; let m = b.sourcePos[0],
          n = b.sourcePos[1] - e,
          o = m,
          p = n - g,
          q = o - g,
          r = p - g; k = 2 * g, l = 2 * g, a.points[0] = q, a.points[1] = r, a.points[2] = k, a.points[3] = l, c.addSegment(this, 'Arc', {
          loopback: !0, x1: m - q + 4, y1: n - r, startAngle: 0, endAngle: 2 * Math.PI, r: g, ac: !f, x2: m - q - 4, y2: n - r, cx: o - q, cy: p - r
        });
      } else h = !1, this._computeBezier(a, b, i, j, k, l);
    }, c = b.Connectors.AbstractConnector.apply(this, arguments);
  }, c.extend(b.Connectors.AbstractBezierConnector, b.Connectors.AbstractConnector); const d = function (a) {
    a = a || {}, this.type = 'Bezier'; let c = b.Connectors.AbstractBezierConnector.apply(this, arguments),
      d = a.curviness || 150,
      e = 10; this.getCurviness = function () { return d; }, this._findControlPoint = function (a, b, c, f, g, h, i) {
      let j = h[0] !== i[0] || h[1] === i[1],
        k = []; return j ? (i[0] === 0 ? k.push(c[0] < b[0] ? a[0] + e : a[0] - e) : k.push(a[0] + d * i[0]), i[1] === 0 ? k.push(c[1] < b[1] ? a[1] + e : a[1] - e) : k.push(a[1] + d * h[1])) : (h[0] === 0 ? k.push(b[0] < c[0] ? a[0] + e : a[0] - e) : k.push(a[0] - d * h[0]), h[1] === 0 ? k.push(b[1] < c[1] ? a[1] + e : a[1] - e) : k.push(a[1] + d * i[1])), k;
    }, this._computeBezier = function (a, b, d, e, f, g) {
      let h,
        i,
        j = this.getGeometry(),
        k = d[0] < e[0] ? f : 0,
        l = d[1] < e[1] ? g : 0,
        m = d[0] < e[0] ? 0 : f,
        n = d[1] < e[1] ? 0 : g; (this.hasBeenEdited() || this.isEditing()) && j != null && j.controlPoints != null && j.controlPoints[0] != null && j.controlPoints[1] != null ? (h = j.controlPoints[0], i = j.controlPoints[1]) : (h = this._findControlPoint([k, l], d, e, b.sourceEndpoint, b.targetEndpoint, a.so, a.to), i = this._findControlPoint([m, n], e, d, b.targetEndpoint, b.sourceEndpoint, a.to, a.so)), c.setGeometry({ controlPoints: [h, i] }, !0), c.addSegment(this, 'Bezier', {
        x1: k, y1: l, x2: m, y2: n, cp1x: h[0], cp1y: h[1], cp2x: i[0], cp2y: i[1]
      });
    };
  }; c.extend(d, b.Connectors.AbstractBezierConnector), b.registerConnectorType(d, 'Bezier');
}.call(typeof window !== 'undefined' ? window : this), function () {
  let a = this,
    b = a.jsPlumb,
    c = a.jsPlumbUtil,
    d = function (a, b, c, d) { return c >= a && b >= d ? 1 : c >= a && d >= b ? 2 : a >= c && d >= b ? 3 : 4; },
    e = function (a, b, c, d, e, f, g, h, i) { return i >= h ? [a, b] : c === 1 ? d[3] <= 0 && e[3] >= 1 ? [a + (d[2] < 0.5 ? -1 * f : f), b] : d[2] >= 1 && e[2] <= 0 ? [a, b + (d[3] < 0.5 ? -1 * g : g)] : [a + -1 * f, b + -1 * g] : c === 2 ? d[3] >= 1 && e[3] <= 0 ? [a + (d[2] < 0.5 ? -1 * f : f), b] : d[2] >= 1 && e[2] <= 0 ? [a, b + (d[3] < 0.5 ? -1 * g : g)] : [a + f, b + -1 * g] : c === 3 ? d[3] >= 1 && e[3] <= 0 ? [a + (d[2] < 0.5 ? -1 * f : f), b] : d[2] <= 0 && e[2] >= 1 ? [a, b + (d[3] < 0.5 ? -1 * g : g)] : [a + -1 * f, b + -1 * g] : c === 4 ? d[3] <= 0 && e[3] >= 1 ? [a + (d[2] < 0.5 ? -1 * f : f), b] : d[2] <= 0 && e[2] >= 1 ? [a, b + (d[3] < 0.5 ? -1 * g : g)] : [a + f, b + -1 * g] : void 0; },
    f = function (a) {
      a = a || {}, this.type = 'StateMachine'; let c,
        f = b.Connectors.AbstractBezierConnector.apply(this, arguments),
        g = a.curviness || 10,
        h = a.margin || 5,
        i = a.proximityLimit || 80; a.orientation && a.orientation === 'clockwise', this._computeBezier = function (a, b, j, k, l, m) {
        let n = b.sourcePos[0] < b.targetPos[0] ? 0 : l,
          o = b.sourcePos[1] < b.targetPos[1] ? 0 : m,
          p = b.sourcePos[0] < b.targetPos[0] ? l : 0,
          q = b.sourcePos[1] < b.targetPos[1] ? m : 0; b.sourcePos[2] === 0 && (n -= h), b.sourcePos[2] === 1 && (n += h), b.sourcePos[3] === 0 && (o -= h), b.sourcePos[3] === 1 && (o += h), b.targetPos[2] === 0 && (p -= h), b.targetPos[2] === 1 && (p += h), b.targetPos[3] === 0 && (q -= h), b.targetPos[3] === 1 && (q += h); let r,
          s,
          t,
          u,
          v = (n + p) / 2,
          w = (o + q) / 2,
          x = d(n, o, p, q),
          y = Math.sqrt(Math.pow(p - n, 2) + Math.pow(q - o, 2)),
          z = f.getGeometry(); (this.hasBeenEdited() || this.isEditing()) && z != null ? (r = z.controlPoints[0][0], t = z.controlPoints[0][1], s = z.controlPoints[1][0], u = z.controlPoints[1][1]) : (c = e(v, w, x, b.sourcePos, b.targetPos, g, g, y, i), r = c[0], s = c[0], t = c[1], u = c[1], f.setGeometry({ controlPoints: [c, c] }, !0)), f.addSegment(this, 'Bezier', {
          x1: p, y1: q, x2: n, y2: o, cp1x: r, cp1y: t, cp2x: s, cp2y: u
        });
      };
    }; c.extend(f, b.Connectors.AbstractBezierConnector), b.registerConnectorType(f, 'StateMachine');
}.call(typeof window !== 'undefined' ? window : this), function () {
  let a = this,
    b = a.jsPlumb,
    c = a.jsPlumbUtil,
    d = 'Straight',
    e = function () {
      this.type = d; const a = b.Connectors.AbstractConnector.apply(this, arguments); this._compute = function (b) {
        a.addSegment(this, d, {
          x1: b.sx, y1: b.sy, x2: b.startStubX, y2: b.startStubY
        }), a.addSegment(this, d, {
          x1: b.startStubX, y1: b.startStubY, x2: b.endStubX, y2: b.endStubY
        }), a.addSegment(this, d, {
          x1: b.endStubX, y1: b.endStubY, x2: b.tx, y2: b.ty
        });
      };
    }; c.extend(e, b.Connectors.AbstractConnector), b.registerConnectorType(e, d);
}.call(typeof window !== 'undefined' ? window : this), function () {
  let a = this,
    b = a.jsPlumb,
    c = a.jsPlumbUtil,
    d = { 'stroke-linejoin': 'stroke-linejoin', 'stroke-dashoffset': 'stroke-dashoffset', 'stroke-linecap': 'stroke-linecap' },
    e = 'stroke-dasharray',
    f = 'dashstyle',
    g = 'linearGradient',
    h = 'radialGradient',
    i = 'defs',
    j = 'fill',
    k = 'stop',
    l = 'stroke',
    m = 'stroke-width',
    n = 'style',
    o = 'none',
    p = 'jsplumb_gradient_',
    q = 'strokeWidth',
    r = { svg: 'http://www.w3.org/2000/svg' },
    s = function (a, b) { for (const c in b)a.setAttribute(c, `${b[c]}`); },
    t = function (a, c) { return c = c || {}, c.version = '1.1', c.xmlns = r.svg, b.createElementNS(r.svg, a, null, null, c); },
    u = function (a) { return `position:absolute;left:${a[0]}px;top:${a[1]}px`; },
    v = function (a) { for (let b = a.querySelectorAll(' defs,linearGradient,radialGradient'), c = 0; c < b.length; c++)b[c].parentNode.removeChild(b[c]); },
    w = function (a, b, c, d, e) {
      const f = p + e._jsPlumb.instance.idstamp(); v(a); let m; m = c.gradient.offset ? t(h, { id: f }) : t(g, { id: f, gradientUnits: 'userSpaceOnUse' }); const n = t(i); a.appendChild(n), n.appendChild(m); for (let o = 0; o < c.gradient.stops.length; o++) {
        let q = e.segment === 1 || e.segment === 2 ? o : c.gradient.stops.length - 1 - o,
          r = c.gradient.stops[q][1],
          s = t(k, { offset: `${Math.floor(100 * c.gradient.stops[o][0])}%`, 'stop-color': r }); m.appendChild(s);
      } const u = c.stroke ? l : j; b.setAttribute(u, `url(#${f})`);
    },
    x = function (a, b, c, g, h) {
      if (b.setAttribute(j, c.fill ? c.fill : o), b.setAttribute(l, c.stroke ? c.stroke : o), c.gradient ? w(a, b, c, g, h) : (v(a), b.setAttribute(n, '')), c.strokeWidth && b.setAttribute(m, c.strokeWidth), c[f] && c[q] && !c[e]) {
        let i = c[f].indexOf(',') === -1 ? ' ' : ',',
          k = c[f].split(i),
          p = ''; k.forEach((a) => { p += Math.floor(a * c.strokeWidth) + i; }), b.setAttribute(e, p);
      } else c[e] && b.setAttribute(e, c[e]); for (const r in d)c[r] && b.setAttribute(d[r], c[r]);
    },
    y = function (a, b, c) { a.childNodes.length > c ? a.insertBefore(b, a.childNodes[c]) : a.appendChild(b); }; c.svg = { node: t, attr: s, pos: u }; const z = function (a) {
    let d = a.pointerEventsSpec || 'all',
      e = {}; b.jsPlumbUIComponent.apply(this, a.originalArgs), this.canvas = null, this.path = null, this.svg = null, this.bgCanvas = null; let f = `${a.cssClass} ${a.originalArgs[0].cssClass || ''}`,
      g = {
        style: '', width: 0, height: 0, 'pointer-events': d, position: 'absolute'
      }; this.svg = t('svg', g), a.useDivWrapper ? (this.canvas = b.createElement('div', { position: 'absolute' }), c.sizeElement(this.canvas, 0, 0, 1, 1), this.canvas.className = f) : (s(this.svg, { class: f }), this.canvas = this.svg), a._jsPlumb.appendElement(this.canvas, a.originalArgs[0].parent), a.useDivWrapper && this.canvas.appendChild(this.svg); const h = [this.canvas]; return this.getDisplayElements = function () { return h; }, this.appendDisplayElement = function (a) { h.push(a); }, this.paint = function (b, d, f) {
      if (b != null) {
        let g,
          h = [this.x, this.y],
          i = [this.w, this.h]; f != null && (f.xmin < 0 && (h[0] += f.xmin), f.ymin < 0 && (h[1] += f.ymin), i[0] = f.xmax + (f.xmin < 0 ? -f.xmin : 0), i[1] = f.ymax + (f.ymin < 0 ? -f.ymin : 0)), a.useDivWrapper ? (c.sizeElement(this.canvas, h[0], h[1], i[0], i[1]), h[0] = 0, h[1] = 0, g = u([0, 0])) : g = u([h[0], h[1]]), e.paint.apply(this, arguments), s(this.svg, { style: g, width: i[0] || 0, height: i[1] || 0 });
      }
    }, { renderer: e };
  }; c.extend(z, b.jsPlumbUIComponent, { cleanup(a) { a || this.typeId == null ? (this.canvas && (this.canvas._jsPlumb = null), this.svg && (this.svg._jsPlumb = null), this.bgCanvas && (this.bgCanvas._jsPlumb = null), this.canvas && this.canvas.parentNode && this.canvas.parentNode.removeChild(this.canvas), this.bgCanvas && this.bgCanvas.parentNode && this.canvas.parentNode.removeChild(this.canvas), this.svg = null, this.canvas = null, this.path = null, this.group = null) : (this.canvas && this.canvas.parentNode && this.canvas.parentNode.removeChild(this.canvas), this.bgCanvas && this.bgCanvas.parentNode && this.bgCanvas.parentNode.removeChild(this.bgCanvas)); }, reattach(a) { const b = a.getContainer(); this.canvas && this.canvas.parentNode == null && b.appendChild(this.canvas), this.bgCanvas && this.bgCanvas.parentNode == null && b.appendChild(this.bgCanvas); }, setVisible(a) { this.canvas && (this.canvas.style.display = a ? 'block' : 'none'); } }), b.ConnectorRenderers.svg = function (a) {
    let c = this,
      d = z.apply(this, [{
        cssClass: a._jsPlumb.connectorClass + (this.isEditable() ? ` ${a._jsPlumb.editableConnectorClass}` : ''), originalArgs: arguments, pointerEventsSpec: 'none', _jsPlumb: a._jsPlumb
      }]),
      e = this.setEditable; this.setEditable = function (a) { const c = e.apply(this, [a]); b[c ? 'addClass' : 'removeClass'](this.canvas, this._jsPlumb.instance.editableConnectorClass); }, d.renderer.paint = function (d, e, f) {
      let g = c.getSegments(),
        h = '',
        i = [0, 0]; if (f.xmin < 0 && (i[0] = -f.xmin), f.ymin < 0 && (i[1] = -f.ymin), g.length > 0) {
        h = c.getPathData(); let j = { d: h, transform: `translate(${i[0]},${i[1]})`, 'pointer-events': a['pointer-events'] || 'visibleStroke' },
          k = null,
          l = [c.x, c.y, c.w, c.h]; if (d.outlineStroke) {
          let m = d.outlineWidth || 1,
            n = d.strokeWidth + 2 * m; k = b.extend({}, d), delete k.gradient, k.stroke = d.outlineStroke, k.strokeWidth = n, c.bgPath == null ? (c.bgPath = t('path', j), b.addClass(c.bgPath, b.connectorOutlineClass), y(c.svg, c.bgPath, 0)) : s(c.bgPath, j), x(c.svg, c.bgPath, k, l, c);
        }c.path == null ? (c.path = t('path', j), y(c.svg, c.path, d.outlineStroke ? 1 : 0)) : s(c.path, j), x(c.svg, c.path, d, l, c);
      }
    };
  }, c.extend(b.ConnectorRenderers.svg, z); const A = b.SvgEndpoint = function (a) {
    const c = z.apply(this, [{
      cssClass: a._jsPlumb.endpointClass, originalArgs: arguments, pointerEventsSpec: 'all', useDivWrapper: !0, _jsPlumb: a._jsPlumb
    }]); c.renderer.paint = function (a) { const c = b.extend({}, a); c.outlineStroke && (c.stroke = c.outlineStroke), this.node == null ? (this.node = this.makeNode(c), this.svg.appendChild(this.node)) : this.updateNode != null && this.updateNode(this.node), x(this.svg, this.node, c, [this.x, this.y, this.w, this.h], this), u(this.node, [this.x, this.y]); }.bind(this);
  }; c.extend(A, z), b.Endpoints.svg.Dot = function () { b.Endpoints.Dot.apply(this, arguments), A.apply(this, arguments), this.makeNode = function () { return t('circle', { cx: this.w / 2, cy: this.h / 2, r: this.radius }); }, this.updateNode = function (a) { s(a, { cx: this.w / 2, cy: this.h / 2, r: this.radius }); }; }, c.extend(b.Endpoints.svg.Dot, [b.Endpoints.Dot, A]), b.Endpoints.svg.Rectangle = function () { b.Endpoints.Rectangle.apply(this, arguments), A.apply(this, arguments), this.makeNode = function () { return t('rect', { width: this.w, height: this.h }); }, this.updateNode = function (a) { s(a, { width: this.w, height: this.h }); }; }, c.extend(b.Endpoints.svg.Rectangle, [b.Endpoints.Rectangle, A]), b.Endpoints.svg.Image = b.Endpoints.Image, b.Endpoints.svg.Blank = b.Endpoints.Blank, b.Overlays.svg.Label = b.Overlays.Label, b.Overlays.svg.Custom = b.Overlays.Custom; const B = function (a, c) {
    a.apply(this, c), b.jsPlumbUIComponent.apply(this, c), this.isAppendedAtTopLevel = !1, this.path = null, this.paint = function (a, b) {
      if (a.component.svg && b) {
        this.path == null && (this.path = t('path', { 'pointer-events': 'all' }), a.component.svg.appendChild(this.path), this.elementCreated && this.elementCreated(this.path, a.component), this.canvas = a.component.svg); let e = c && c.length === 1 ? c[0].cssClass || '' : '',
          f = [0, 0]; b.xmin < 0 && (f[0] = -b.xmin), b.ymin < 0 && (f[1] = -b.ymin), s(this.path, {
          d: d(a.d), class: e, stroke: a.stroke ? a.stroke : null, fill: a.fill ? a.fill : null, transform: `translate(${f[0]},${f[1]})`
        });
      }
    }; var d = function (a) { return isNaN(a.cxy.x) || isNaN(a.cxy.y) ? '' : `M${a.hxy.x},${a.hxy.y} L${a.tail[0].x},${a.tail[0].y} L${a.cxy.x},${a.cxy.y} L${a.tail[1].x},${a.tail[1].y} L${a.hxy.x},${a.hxy.y}`; }; this.transfer = function (a) { a.canvas && this.path && this.path.parentNode && (this.path.parentNode.removeChild(this.path), a.canvas.appendChild(this.path)); };
  }; c.extend(B, [b.jsPlumbUIComponent, b.Overlays.AbstractOverlay], { cleanup(a) { this.path != null && (a ? this._jsPlumb.instance.removeElement(this.path) : this.path.parentNode && this.path.parentNode.removeChild(this.path)); }, reattach(a, b) { this.path && b.canvas && b.canvas.appendChild(this.path); }, setVisible(a) { this.path != null && (this.path.style.display = a ? 'block' : 'none'); } }), b.Overlays.svg.Arrow = function () { B.apply(this, [b.Overlays.Arrow, arguments]); }, c.extend(b.Overlays.svg.Arrow, [b.Overlays.Arrow, B]), b.Overlays.svg.PlainArrow = function () { B.apply(this, [b.Overlays.PlainArrow, arguments]); }, c.extend(b.Overlays.svg.PlainArrow, [b.Overlays.PlainArrow, B]), b.Overlays.svg.Diamond = function () { B.apply(this, [b.Overlays.Diamond, arguments]); }, c.extend(b.Overlays.svg.Diamond, [b.Overlays.Diamond, B]), b.Overlays.svg.GuideLines = function () {
    let a,
      c,
      d = null,
      e = this; b.Overlays.GuideLines.apply(this, arguments), this.paint = function (b, g) {
      d == null && (d = t('path'), b.connector.svg.appendChild(d), e.attachListeners(d, b.connector), e.attachListeners(d, e), a = t('path'), b.connector.svg.appendChild(a), e.attachListeners(a, b.connector), e.attachListeners(a, e), c = t('path'), b.connector.svg.appendChild(c), e.attachListeners(c, b.connector), e.attachListeners(c, e));
      const h = [0, 0]; g.xmin < 0 && (h[0] = -g.xmin), g.ymin < 0 && (h[1] = -g.ymin), s(d, {
        d: f(b.head, b.tail), stroke: 'red', fill: null, transform: `translate(${h[0]},${h[1]})`
      }), s(a, {
        d: f(b.tailLine[0], b.tailLine[1]), stroke: 'blue', fill: null, transform: `translate(${h[0]},${h[1]})`
      }), s(c, {
        d: f(b.headLine[0], b.headLine[1]), stroke: 'green', fill: null, transform: `translate(${h[0]},${h[1]})`
      });
    }; var f = function (a, b) { return `M ${a.x},${a.y} L${b.x},${b.y}`; };
  }, c.extend(b.Overlays.svg.GuideLines, b.Overlays.GuideLines);
}.call(typeof window !== 'undefined' ? window : this), function () {
  let a = this,
    b = a.jsPlumb,
    c = a.jsPlumbUtil,
    d = a.Katavorio,
    e = a.Biltong,
    f = function (a, c) {
      c = c || 'main'; let f = `_katavorio_${c}`,
        g = a[f],
        h = a.getEventManager(); return g || (g = new d({
        bind: h.on,
        unbind: h.off,
        getSize: b.getSize,
        getConstrainingRectangle(a) { return [a.parentNode.scrollWidth, a.parentNode.scrollHeight]; },
        getPosition(b, c) { const d = a.getOffset(b, c, b._katavorioDrag ? b.offsetParent : null); return [d.left, d.top]; },
        setPosition(a, b) { a.style.left = `${b[0]}px`, a.style.top = `${b[1]}px`; },
        addClass: b.addClass,
        removeClass: b.removeClass,
        intersects: e.intersects,
        indexOf(a, b) { return a.indexOf(b); },
        scope: a.getDefaultScope(),
        css: {
          noSelect: a.dragSelectClass, droppable: 'jtk-droppable', draggable: 'jtk-draggable', drag: 'jtk-drag', selected: 'jtk-drag-selected', active: 'jtk-drag-active', hover: 'jtk-drag-hover', ghostProxy: 'jtk-ghost-proxy'
        }
      }), g.setZoom(a.getZoom()), a[f] = g, a.bind('zoom', g.setZoom)), g;
    },
    g = function (a, b) {
      const d = function (d) {
        if (b[d] != null) {
          if (c.isString(b[d])) {
            let e = b[d].match(/-=/) ? -1 : 1,
              f = b[d].substring(2); return a[d] + e * f;
          } return b[d];
        } return a[d];
      }; return [d('left'), d('top')];
    }; b.extend(a.jsPlumbInstance.prototype, {
    animationSupported: !0,
    getElement(a) { return a == null ? null : (a = typeof a === 'string' ? a : a.length != null && a.enctype == null ? a[0] : a, typeof a === 'string' ? document.getElementById(a) : a); },
    removeElement(a) { f(this).elementRemoved(a), this.getEventManager().remove(a); },
    doAnimate(a, c, d) {
      d = d || {}; var e = this.getOffset(a),
        f = g(e, c),
        h = f[0] - e.left,
        i = f[1] - e.top,
        j = d.duration || 250,
        k = 15,
        l = j / k,
        m = k / j * h,
        n = k / j * i,
        o = 0,
        p = setInterval(() => { b.setPosition(a, { left: e.left + m * (o + 1), top: e.top + n * (o + 1) }), d.step != null && d.step(o, Math.ceil(l)), o++, o >= l && (window.clearInterval(p), d.complete != null && d.complete()); }, k);
    },
    destroyDraggable(a, b) { f(this, b).destroyDraggable(a); },
    destroyDroppable(a, b) { f(this, b).destroyDroppable(a); },
    initDraggable(a, b, c) { f(this, c).draggable(a, b); },
    initDroppable(a, b, c) { f(this, c).droppable(a, b); },
    isAlreadyDraggable(a) { return a._katavorioDrag != null; },
    isDragSupported() { return !0; },
    isDropSupported() { return !0; },
    isElementDraggable(a) { return a = b.getElement(a), a._katavorioDrag && a._katavorioDrag.isEnabled(); },
    getDragObject(a) { return a[0].drag.getDragElement(); },
    getDragScope(a) { return a._katavorioDrag && a._katavorioDrag.scopes.join(' ') || ''; },
    getDropEvent(a) { return a[0].e; },
    getUIPosition(a) {
      const b = a[0].el; if (b.offsetParent == null) return null; let c = a[0].finalPos || a[0].pos,
        d = { left: c[0], top: c[1] }; if (b._katavorioDrag && b.offsetParent !== this.getContainer()) { const e = this.getOffset(b.offsetParent); d.left += e.left, d.top += e.top; } return d;
    },
    setDragFilter(a, b, c) { a._katavorioDrag && a._katavorioDrag.setFilter(b, c); },
    setElementDraggable(a, c) { a = b.getElement(a), a._katavorioDrag && a._katavorioDrag.setEnabled(c); },
    setDragScope(a, b) { a._katavorioDrag && a._katavorioDrag.k.setDragScope(a, b); },
    setDropScope(a, b) { a._katavorioDrop && a._katavorioDrop.length > 0 && a._katavorioDrop[0].k.setDropScope(a, b); },
    addToPosse(a) {
      let c = Array.prototype.slice.call(arguments, 1),
        d = f(this); b.each(a, (a) => { a = [b.getElement(a)], a.push(...c), d.addToPosse(...a); });
    },
    setPosse(a) {
      let c = Array.prototype.slice.call(arguments, 1),
        d = f(this); b.each(a, (a) => { a = [b.getElement(a)], a.push(...c), d.setPosse(...a); });
    },
    removeFromPosse(a) {
      let c = Array.prototype.slice.call(arguments, 1),
        d = f(this); b.each(a, (a) => { a = [b.getElement(a)], a.push(...c), d.removeFromPosse(...a); });
    },
    removeFromAllPosses(a) { const c = f(this); b.each(a, (a) => { c.removeFromAllPosses(b.getElement(a)); }); },
    setPosseState(a, c, d) { const e = f(this); b.each(a, (a) => { e.setPosseState(b.getElement(a), c, d); }); },
    dragEvents: {
      start: 'start', stop: 'stop', drag: 'drag', step: 'step', over: 'over', out: 'out', drop: 'drop', complete: 'complete', beforeStart: 'beforeStart'
    },
    animEvents: { step: 'step', complete: 'complete' },
    stopDrag(a) { a._katavorioDrag && a._katavorioDrag.abort(); },
    addToDragSelection(a) { f(this).select(a); },
    removeFromDragSelection(a) { f(this).deselect(a); },
    clearDragSelection() { f(this).deselectAll(); },
    trigger(a, b, c, d) { this.getEventManager().trigger(a, b, c, d); },
    doReset() { for (const a in this)a.indexOf('_katavorio_') === 0 && this[a].reset(); }
  }); const h = function (a) { var b = function () { /complete|loaded|interactive/.test(document.readyState) && typeof document.body !== 'undefined' && document.body != null ? a() : setTimeout(b, 9); }; b(); }; h(b.init);
}.call(typeof window !== 'undefined' ? window : this);
